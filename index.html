<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MusicBrainz Songsterr Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap');

        :root {
            --primary-blue: #0f766e;
            --primary-blue-light: #14b8a6;
            --primary-blue-dark: #0f4c4f;
            --primary: #0f766e;
            --primary-dark: #0f4c4f;
            --accent-orange: #f59e0b;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --gray-50: #f7f8fb;
            --gray-100: #eef2f7;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #94a3b8;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1f2937;
            --gray-900: #0f172a;
            --success: #059669;
            --warning: #d97706;
            --error: #dc2626;
            --surface: #ffffff;
        }

        body {
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--gray-50);
            color: var(--gray-900);
            line-height: 1.6;
            transition: all 0.2s ease;
        }

        .app-shell {
            position: relative;
            background: linear-gradient(180deg, #f8fafc 0%, #eef2f7 100%);
            overflow-x: hidden;
        }

        .app-shell::before,
        .app-shell::after {
            content: "";
            position: absolute;
            width: 520px;
            height: 520px;
            border-radius: 999px;
            filter: blur(0);
            opacity: 0.35;
            pointer-events: none;
            z-index: 0;
        }

        .app-shell::before {
            top: -180px;
            left: -120px;
            background: radial-gradient(circle, rgba(20, 184, 166, 0.35) 0%, rgba(20, 184, 166, 0) 70%);
        }

        .app-shell::after {
            bottom: -220px;
            right: -140px;
            background: radial-gradient(circle, rgba(245, 158, 11, 0.28) 0%, rgba(245, 158, 11, 0) 70%);
        }

        /* Professional card styling */
        .pro-card {
            background: var(--surface);
            border: 1px solid var(--gray-200);
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
        }

        .pro-card:hover {
            box-shadow: 0 16px 30px rgba(15, 23, 42, 0.12);
        }

        /* Professional button styling */
        .pro-button {
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 8px 16px rgba(15, 118, 110, 0.2);
        }

        .pro-button:hover {
            background: var(--primary-blue-dark);
            transform: translateY(-1px);
        }

        .pro-button:active {
            transform: translateY(0);
        }

        .pro-button.secondary {
            background: var(--gray-100);
            color: var(--gray-700);
            border: 1px solid var(--gray-300);
            box-shadow: none;
        }

        .pro-button.secondary:hover {
            background: var(--gray-200);
            color: var(--gray-800);
        }

        /* Professional input styling */
        .pro-input {
            background: var(--surface);
            border: 1px solid var(--gray-300);
            border-radius: 10px;
            color: var(--gray-900);
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .pro-input:focus {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }

        .pro-input::placeholder {
            color: var(--gray-400);
        }

        /* Headers */
        h1,
        h2,
        h3 {
            font-family: 'Playfair Display', serif;
            color: var(--gray-900);
            font-weight: 700;
            margin: 0;
        }

        .hero-card {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid var(--gray-200);
            border-radius: 18px;
            padding: 1.5rem 2rem;
            box-shadow: 0 18px 40px rgba(15, 23, 42, 0.1);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 1;
        }

        /* Logo Styles */
        .logo-container {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .logo-container:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }

        header h1 {
            font-size: 2.5rem;
            line-height: 1.1;
            font-weight: 700;
        }

        header h2 {
            font-size: 1.5rem;
            line-height: 1.2;
            font-weight: 600;
        }

        /* Dark theme - Professional */
        body.dark-theme {
            background-color: var(--gray-900);
            color: var(--gray-100);
        }

        body.dark-theme.app-shell {
            background: linear-gradient(180deg, #0f172a 0%, #111827 100%);
        }

        body.dark-theme.app-shell::before {
            background: radial-gradient(circle, rgba(20, 184, 166, 0.2) 0%, rgba(20, 184, 166, 0) 70%);
        }

        body.dark-theme.app-shell::after {
            background: radial-gradient(circle, rgba(245, 158, 11, 0.18) 0%, rgba(245, 158, 11, 0) 70%);
        }

        body.dark-theme .pro-card {
            background: var(--gray-800);
            border-color: var(--gray-700);
        }

        body.dark-theme .pro-card:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
        }

        body.dark-theme .pro-input {
            background: var(--gray-800);
            border-color: var(--gray-600);
            color: var(--gray-100);
        }

        body.dark-theme .pro-input:focus {
            border-color: var(--primary-blue-light);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        body.dark-theme .pro-button.secondary {
            background: var(--gray-700);
            color: var(--gray-200);
            border-color: var(--gray-600);
        }

        body.dark-theme .pro-button.secondary:hover {
            background: var(--gray-600);
            color: var(--gray-100);
        }

        body.dark-theme h1,
        body.dark-theme h2,
        body.dark-theme h3 {
            color: var(--gray-100);
        }

        body.dark-theme .hero-card {
            background: rgba(15, 23, 42, 0.88);
            border-color: var(--gray-700);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
        }

        body.dark-theme .column-panel {
            background: rgba(15, 23, 42, 0.78);
            border-right-color: var(--gray-700);
        }

        body.dark-theme .column-panel--tint,
        body.dark-theme .column-panel--tint-2 {
            background: rgba(17, 24, 39, 0.75);
        }

        body.dark-theme .column-header {
            border-bottom-color: var(--gray-700);
            background: linear-gradient(90deg, rgba(20, 184, 166, 0.16), rgba(245, 158, 11, 0.12));
        }

        body.dark-theme .column-title {
            color: var(--gray-100);
        }

        /* Dark theme logo styles */
        body.dark-theme header h2 {
            color: var(--gray-300);
        }

        body.dark-theme header p {
            color: var(--gray-400);
        }

        body.dark-theme .bg-white {
            background-color: #374151 !important;
        }

        body.dark-theme .bg-gray-50 {
            background-color: #4b5563 !important;
        }

        body.dark-theme .bg-gray-100 {
            background-color: #374151 !important;
        }

        body.dark-theme .text-gray-800 {
            color: #ffffff !important;
        }

        body.dark-theme .text-gray-700 {
            color: #ffffff !important;
        }

        body.dark-theme .text-gray-600 {
            color: #ffffff !important;
        }

        body.dark-theme .text-gray-500 {
            color: #ffffff !important;
        }

        body.dark-theme .text-gray-400 {
            color: #ffffff !important;
        }

        body.dark-theme .text-gray-300 {
            color: #ffffff !important;
        }

        body.dark-theme .text-blue-600 {
            color: #60a5fa !important;
        }

        body.dark-theme .text-blue-500 {
            color: #3b82f6 !important;
        }

        body.dark-theme .text-green-600 {
            color: #4ade80 !important;
        }

        body.dark-theme .text-green-500 {
            color: #22c55e !important;
        }

        body.dark-theme .text-yellow-600 {
            color: #facc15 !important;
        }

        body.dark-theme .text-red-500 {
            color: #ef4444 !important;
        }

        body.dark-theme .text-red-600 {
            color: #dc2626 !important;
        }

        body.dark-theme .text-red-800 {
            color: #ef4444 !important;
        }

        body.dark-theme .text-white {
            color: #ffffff !important;
        }

        /* Ensure all text in lists is white in dark theme */
        body.dark-theme .list-item span,
        body.dark-theme .list-item div,
        body.dark-theme #artist-list span,
        body.dark-theme #album-list span,
        body.dark-theme #track-list span {
            color: #ffffff !important;
        }

        /* Override any specific text colors in dark theme */
        body.dark-theme .font-medium,
        body.dark-theme .font-semibold,
        body.dark-theme .font-bold {
            color: #ffffff !important;
        }

        body.dark-theme .border-gray-200 {
            border-color: #4b5563 !important;
        }

        body.dark-theme .border-gray-300 {
            border-color: #6b7280 !important;
        }

        body.dark-theme .border-gray-100 {
            border-color: #374151 !important;
        }

        body.dark-theme .divide-gray-200>*+* {
            border-color: #4b5563 !important;
        }

        body.dark-theme .divide-gray-100>*+* {
            border-color: #374151 !important;
        }

        body.dark-theme .hover\:bg-gray-100:hover {
            background-color: #4b5563 !important;
        }

        body.dark-theme .hover\:bg-gray-200:hover {
            background-color: #6b7280 !important;
        }

        body.dark-theme .bg-blue-50 {
            background-color: #1e3a8a !important;
        }

        body.dark-theme .bg-green-50 {
            background-color: #14532d !important;
        }

        body.dark-theme .bg-yellow-50 {
            background-color: #451a03 !important;
        }

        body.dark-theme .border-blue-500 {
            border-color: #3b82f6 !important;
        }

        body.dark-theme .border-green-500 {
            border-color: #10b981 !important;
        }

        body.dark-theme .border-yellow-500 {
            border-color: #f59e0b !important;
        }

        body.dark-theme .list-item:hover {
            background-color: #4b5563;
        }

        body.dark-theme .active-item {
            background-color: #6b7280;
        }

        body.dark-theme .suggestion-item:hover {
            background-color: #4b5563;
        }

        body.dark-theme .suggestion-item.highlighted {
            background-color: #6b7280;
        }

        /* Input fields in dark theme */
        body.dark-theme input[type="text"],
        body.dark-theme select {
            background-color: #374151 !important;
            color: #ffffff !important;
            border-color: #6b7280 !important;
        }

        body.dark-theme input[type="text"]::placeholder {
            color: #9ca3af !important;
        }

        body.dark-theme input[type="text"]:focus,
        body.dark-theme select:focus {
            border-color: #3b82f6 !important;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1) !important;
        }

        /* Button hover states in dark theme */
        body.dark-theme .hover\:text-gray-700:hover {
            color: #f3f4f6 !important;
        }

        body.dark-theme .hover\:text-red-700:hover {
            color: #ef4444 !important;
        }

        /* YouTube button styles */
        .youtube-btn:hover {
            background-color: #fef2f2 !important;
        }

        body.dark-theme .youtube-btn:hover {
            background-color: #7f1d1d !important;
        }

        body.dark-theme .text-red-600 {
            color: #f87171 !important;
        }

        body.dark-theme .text-red-800 {
            color: #fca5a5 !important;
        }

        /* Professional theme selector */
        .theme-selector {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 50;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            padding: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 4px;
        }

        body.dark-theme .theme-selector {
            background: var(--gray-800);
            border-color: var(--gray-600);
        }

        .theme-option {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            color: var(--gray-600);
        }

        .theme-option:hover {
            background-color: var(--gray-100);
            color: var(--gray-800);
        }

        .theme-option.active {
            background-color: var(--primary-blue);
            color: white;
        }

        body.dark-theme .theme-option {
            color: var(--gray-400);
        }

        body.dark-theme .theme-option:hover {
            background-color: var(--gray-700);
            color: var(--gray-200);
        }

        /* Professional random button */
        .top-controls {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .random-song-btn {
            background: var(--accent-orange);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            min-width: 100px;
        }

        .random-song-btn:hover {
            background: var(--warning);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .random-song-btn i {
            font-size: 14px;
            transition: transform 0.2s ease;
        }

        .random-song-btn:hover i {
            transform: rotate(90deg);
        }

        .random-song-btn.loading i {
            animation: simple-spin 1s linear infinite;
        }

        @keyframes simple-spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Professional favorites menu */
        .favorites-menu {
            position: fixed;
            top: 8rem;
            right: 1rem;
            z-index: 50;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            padding: 4px 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            min-width: 180px;
        }

        body.dark-theme .favorites-menu {
            background: var(--gray-800);
            border-color: var(--gray-600);
        }

        .favorites-menu-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            color: var(--gray-700);
            font-size: 14px;
            font-weight: 400;
        }

        .favorites-menu-item:hover {
            background-color: var(--gray-100);
            color: var(--gray-900);
        }

        .favorites-menu-item i {
            margin-right: 8px;
            width: 16px;
            text-align: center;
            font-size: 14px;
        }

        body.dark-theme .favorites-menu-item {
            color: var(--gray-300);
        }

        body.dark-theme .favorites-menu-item:hover {
            background-color: var(--gray-700);
            color: var(--gray-100);
        }

        .favorites-menu-toggle {
            background: var(--gray-100);
            color: var(--gray-700);
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            min-width: 100px;
        }

        .favorites-menu-toggle:hover {
            background: var(--gray-200);
            color: var(--gray-800);
        }

        body.dark-theme .favorites-menu-toggle {
            background: var(--gray-700);
            color: var(--gray-300);
            border-color: var(--gray-600);
        }

        body.dark-theme .favorites-menu-toggle:hover {
            background: var(--gray-600);
            color: var(--gray-200);
        }

        /* Professional favorites button */
        #favorites-button {
            background: var(--accent-red) !important;
            color: white !important;
            border: 1px solid var(--accent-red) !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            transition: all 0.2s ease !important;
            box-shadow: none !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 6px !important;
            min-width: 100px !important;
        }

        #favorites-button:hover {
            background: var(--error) !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
        }

        /* Top controls container */
        .top-controls {
            position: fixed;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 50;
        }

        .top-controls button,
        .top-controls .random-song-btn {
            background: var(--primary) !important;
            color: white !important;
            border: 1px solid var(--primary) !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            transition: all 0.2s ease !important;
            box-shadow: none !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 6px !important;
            min-width: 100px !important;
            cursor: pointer !important;
        }

        .top-controls button:hover,
        .top-controls .random-song-btn:hover {
            background: var(--primary-dark) !important;
            transform: translateY(-1px);
        }

        .top-controls #favorites-button {
            background: var(--accent-red) !important;
            border-color: var(--accent-red) !important;
        }

        .top-controls #favorites-button:hover {
            background: var(--error) !important;
        }

        body.dark-theme .top-controls button,
        body.dark-theme .top-controls .random-song-btn {
            background: var(--gray-700) !important;
            color: var(--gray-200) !important;
            border-color: var(--gray-600) !important;
        }

        body.dark-theme .top-controls button:hover,
        body.dark-theme .top-controls .random-song-btn:hover {
            background: var(--gray-600) !important;
        }

        body.dark-theme .top-controls #favorites-button {
            background: var(--accent-red) !important;
            border-color: var(--accent-red) !important;
        }

        body.dark-theme .top-controls #favorites-button:hover {
            background: var(--error) !important;
        }

        /* Professional scrollbars */
        .scrollable-column {
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--gray-400) var(--gray-100);
        }

        .scrollable-column::-webkit-scrollbar {
            width: 8px;
        }

        .scrollable-column::-webkit-scrollbar-track {
            background: var(--gray-100);
            border-radius: 4px;
        }

        .scrollable-column::-webkit-scrollbar-thumb {
            background: var(--gray-400);
            border-radius: 4px;
        }

        .scrollable-column::-webkit-scrollbar-thumb:hover {
            background: var(--gray-500);
        }

        /* Dark theme scrollbar adjustments */
        body.dark-theme .scrollable-column {
            scrollbar-color: var(--gray-600) var(--gray-800);
        }

        body.dark-theme .scrollable-column::-webkit-scrollbar-track {
            background: var(--gray-800);
        }

        body.dark-theme .scrollable-column::-webkit-scrollbar-thumb {
            background: var(--gray-600);
        }

        body.dark-theme .scrollable-column::-webkit-scrollbar-thumb:hover {
            background: var(--gray-500);
        }

        .column-panel {
            background: rgba(255, 255, 255, 0.9);
            border-right: 1px solid var(--gray-200);
        }

        .column-panel--tint {
            background: rgba(248, 250, 252, 0.9);
        }

        .column-panel--tint-2 {
            background: rgba(241, 245, 249, 0.9);
        }

        .column-panel--last {
            border-right: none;
        }

        .column-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--gray-200);
            background: linear-gradient(90deg, rgba(15, 118, 110, 0.08), rgba(245, 158, 11, 0.06));
        }

        .column-title {
            font-size: 1.35rem;
            font-weight: 700;
            letter-spacing: 0.01em;
            color: var(--gray-900);
        }

        .empty-state {
            color: var(--gray-500);
        }

        .empty-state .empty-icon {
            color: var(--gray-300);
        }

        /* Scrollbar styling for suggestions and favorites */
        #search-suggestions,
        #favorites-list {
            scrollbar-width: thin;
            scrollbar-color: var(--gray-400) var(--gray-100);
        }

        #search-suggestions::-webkit-scrollbar,
        #favorites-list::-webkit-scrollbar {
            width: 6px;
        }

        #search-suggestions::-webkit-scrollbar-track,
        #favorites-list::-webkit-scrollbar-track {
            background: var(--gray-100);
            border-radius: 3px;
        }

        #search-suggestions::-webkit-scrollbar-thumb,
        #favorites-list::-webkit-scrollbar-thumb {
            background: var(--gray-400);
            border-radius: 3px;
        }

        #search-suggestions::-webkit-scrollbar-thumb:hover,
        #favorites-list::-webkit-scrollbar-thumb:hover {
            background: var(--gray-500);
        }

        /* Compact list items with minimal borders */
        .list-item {
            cursor: pointer;
            padding: 12px 14px 12px 18px;
            transition: all 0.2s ease;
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.45;
            position: relative;
            background: var(--surface);
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.06);
        }

        .list-item::before {
            content: "";
            position: absolute;
            left: 10px;
            top: 12px;
            bottom: 12px;
            width: 3px;
            border-radius: 999px;
            background: var(--primary-blue);
            opacity: 0;
            transition: opacity 0.2s ease;
        }


        .list-item:hover {
            border-color: var(--primary-blue-light);
            box-shadow: 0 12px 22px rgba(15, 23, 42, 0.08);
            transform: translateY(-1px);
        }

        .list-item:hover::before {
            opacity: 1;
        }

        .list-item.active-item {
            background-color: rgba(15, 118, 110, 0.08);
            border-color: var(--primary-blue);
            font-weight: 600;
        }

        .list-item.active-item::before {
            opacity: 1;
        }

        .list-item-compact {
            padding: 8px 12px 8px 16px;
            border-radius: 10px;
            box-shadow: none;
            background: rgba(255, 255, 255, 0.7);
        }

        .related-section {
            padding: 12px 14px;
            border: 1px dashed var(--gray-300);
            border-radius: 14px;
            background: rgba(248, 250, 252, 0.9);
        }

        .related-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .related-title {
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--gray-700);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .related-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Dark theme list adjustments */
        body.dark-theme .list-item {
            border-color: var(--gray-700);
            color: var(--gray-200);
            background: rgba(30, 41, 59, 0.72);
            box-shadow: none;
        }

        body.dark-theme .list-item:hover {
            border-color: var(--primary-blue-light);
        }

        body.dark-theme .list-item.active-item {
            background-color: rgba(20, 184, 166, 0.14);
            border-color: var(--primary-blue-light);
        }

        body.dark-theme .list-item-compact {
            background: rgba(15, 23, 42, 0.6);
        }

        body.dark-theme .related-section {
            border-color: var(--gray-700);
            background: rgba(15, 23, 42, 0.7);
        }

        body.dark-theme .related-title {
            color: var(--gray-200);
        }

        /* Compact track items */
        .track-item {
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid var(--gray-200);
            background: var(--surface);
            font-size: 13px;
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.06);
        }

        .track-item:hover {
            border-color: var(--primary-blue-light);
            box-shadow: 0 12px 22px rgba(15, 23, 42, 0.08);
            transform: translateY(-1px);
        }

        /* Inline button spacing for tracks */
        .track-item .pro-button {
            padding: 4px 6px;
            min-width: auto;
        }

        .track-item .pro-button i {
            margin: 0;
        }

        body.dark-theme .track-item {
            background: var(--gray-800);
            border-color: var(--gray-700);
            color: var(--gray-200);
        }

        body.dark-theme .track-item:hover {
            border-color: var(--primary-blue-light);
            background-color: var(--gray-700);
        }

        /* Compact suggestion items */
        .suggestion-item {
            cursor: pointer;
            padding: 8px 12px;
            transition: all 0.15s ease;
            font-size: 14px;
            border-bottom: 1px solid var(--gray-200);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.highlighted {
            background-color: var(--primary-blue);
            color: white;
        }

        body.dark-theme .suggestion-item {
            border-bottom-color: var(--gray-700);
            color: var(--gray-200);
        }

        /* Search History Styles */
        .history-item {
            transition: all 0.15s ease;
        }

        .history-item:hover {
            transform: translateX(2px);
        }

        .history-item:hover .remove-history-item {
            opacity: 1;
        }

        .remove-history-item {
            opacity: 0;
            transition: all 0.15s ease;
        }

        body.dark-theme .history-item:hover {
            background-color: var(--gray-700);
        }

        body.dark-theme #search-history-dropdown {
            background: var(--gray-800);
            border-color: var(--gray-600);
        }

        body.dark-theme #search-history-dropdown .border-gray-200 {
            border-color: var(--gray-600);
        }
    </style>
</head>

<body class="app-shell flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Logo Header -->
    <header class="w-full max-w-7xl mb-8">
        <div class="text-center hero-card">
            <div class="flex items-center justify-center mb-3">
                <div
                    class="logo-container bg-gradient-to-br from-emerald-600 to-amber-500 p-4 rounded-2xl shadow-lg mr-4">
                    <i class="fas fa-guitar text-white text-3xl"></i>
                </div>
                <div class="text-left">
                    <h1
                        class="text-4xl font-bold bg-gradient-to-r from-slate-900 to-emerald-600 bg-clip-text text-transparent">
                        MusicBrainz
                    </h1>
                    <h2 class="text-2xl font-semibold text-gray-700">
                        Songsterr Player
                    </h2>
                </div>
            </div>
            <p class="text-gray-600 text-lg mx-auto max-w-3xl">
                Discover music by artist, track, genre, mood, or find the best songs through MusicBrainz and find guitar
                tabs on Songsterr, Youtube and UG
            </p>
        </div>
    </header>

    <!-- Theme Selector -->
    <div class="theme-selector">
        <div class="flex">
            <div class="theme-option active" data-theme="light" title="Light Theme">
                <i class="fas fa-sun"></i>
            </div>
            <div class="theme-option" data-theme="dark" title="Dark Theme">
                <i class="fas fa-moon"></i>
            </div>
        </div>
    </div>

    <!-- Top Controls Container -->
    <div class="top-controls">
        <!-- Random Song Button -->
        <div class="random-song-btn" id="random-song-btn" title="Get Random Song">
            <i class="fas fa-random"></i>
            <span>Random</span>
        </div>

        <!-- Favorites Menu Toggle -->
        <button id="favorites-menu-toggle" class="favorites-menu-toggle" title="Menu Preferiti">
            <i class="fas fa-cog mr-1"></i>
            <span style="font-size: 0.75rem; font-weight: 500;">Menu</span>
        </button>

        <!-- Favorites Button -->
        <button id="favorites-button" title="View Favorites">
            <i class="fas fa-heart mr-1"></i>
            <span id="favorites-count" class="text-sm font-bold">0</span>
        </button>
    </div>

    <!-- Search Bar -->
    <div class="w-full max-w-7xl mb-4 relative">
        <div class="pro-card p-4 space-y-3">
            <!-- Search type selector -->
            <div class="flex justify-center space-x-4">
                <label class="inline-flex items-center">
                    <input type="radio" name="search-type" value="artist" checked class="form-radio text-blue-500">
                    <span class="ml-2 text-gray-700 font-medium text-sm">
                        <i class="fas fa-user mr-1 text-blue-500"></i>Artist
                    </span>
                </label>
                <label class="inline-flex items-center">
                    <input type="radio" name="search-type" value="track" class="form-radio text-blue-500">
                    <span class="ml-2 text-gray-700 font-medium text-sm">
                        <i class="fas fa-play-circle mr-1 text-green-500"></i>Track
                    </span>
                </label>
                <label class="inline-flex items-center">
                    <input type="radio" name="search-type" value="genre" class="form-radio text-blue-500">
                    <span class="ml-2 text-gray-700 font-medium text-sm">
                        <i class="fas fa-music mr-1 text-purple-500"></i>Genre
                    </span>
                </label>
                <label class="inline-flex items-center">
                    <input type="radio" name="search-type" value="mood" class="form-radio text-blue-500">
                    <span class="ml-2 text-gray-700 font-medium text-sm">
                        <i class="fas fa-heart mr-1 text-pink-500"></i>Mood
                    </span>
                </label>
                <label class="inline-flex items-center">
                    <input type="radio" name="search-type" value="best-of" class="form-radio text-blue-500">
                    <span class="ml-2 text-gray-700 font-medium text-sm">
                        <i class="fas fa-star mr-1 text-yellow-500"></i>Best of
                    </span>
                </label>
            </div>

            <!-- Search fields container -->
            <div class="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-3">
                <!-- Artist search field -->
                <div id="artist-search-container" class="relative w-full sm:w-2/3">
                    <input type="text" id="artist-search" placeholder="Search for an artist (e.g. Black Sabbath)"
                        class="pro-input w-full px-3 py-2 text-sm rounded-lg focus:outline-none" autocomplete="off">
                    <!-- Artist suggestions dropdown -->
                    <div id="search-suggestions"
                        class="absolute top-full left-0 right-0 pro-card mt-1 rounded-lg shadow-lg z-50 max-h-60 overflow-y-auto hidden">
                        <div id="suggestions-loading" class="hidden p-3 text-center text-gray-500 text-sm">
                            <i class="fas fa-spinner fa-spin mr-2"></i>Loading...
                        </div>
                        <ul id="suggestions-list" class="">
                            <!-- Suggestions populated by JS -->
                        </ul>
                    </div>
                </div>

                <!-- Track search field -->
                <div id="track-search-container" class="relative w-full sm:w-2/3 hidden">
                    <input type="text" id="track-search" placeholder="Search for a song (e.g. Stairway to Heaven)"
                        class="pro-input w-full px-3 py-2 text-sm rounded-lg focus:outline-none" autocomplete="off">
                    <!-- Track suggestions dropdown -->
                    <div id="track-suggestions"
                        class="absolute top-full left-0 right-0 pro-card mt-1 rounded-lg shadow-lg z-50 max-h-60 overflow-y-auto hidden">
                        <div id="track-suggestions-loading" class="hidden p-3 text-center text-gray-500 text-sm">
                            <i class="fas fa-spinner fa-spin mr-2"></i>Loading...
                        </div>
                        <ul id="track-suggestions-list" class="">
                            <!-- Track suggestions populated by JS -->
                        </ul>
                    </div>
                </div>

                <!-- Genre search field -->
                <div id="genre-search-container" class="relative w-full sm:w-2/3 hidden">
                    <select id="genre-select" class="pro-input w-full px-3 py-2 text-sm rounded-lg focus:outline-none">
                        <option value="">Select a genre...</option>
                    </select>
                </div>

                <!-- Mood search field -->
                <div id="mood-search-container" class="relative w-full sm:w-2/3 hidden">
                    <select id="mood-select" class="pro-input w-full px-3 py-2 text-sm rounded-lg focus:outline-none">
                        <option value="">Select a mood...</option>
                    </select>
                </div>

                <!-- Best of search field -->
                <div id="best-of-search-container" class="relative w-full sm:w-2/3 hidden">
                    <input type="text" id="best-of-search" placeholder="Search artist for best songs (e.g. Queen)"
                        class="pro-input w-full px-3 py-2 text-sm rounded-lg focus:outline-none" autocomplete="off">
                    <!-- Best of suggestions dropdown -->
                    <div id="best-of-suggestions"
                        class="absolute top-full left-0 right-0 pro-card mt-1 rounded-lg shadow-lg z-50 max-h-60 overflow-y-auto hidden">
                        <div id="best-of-suggestions-loading" class="hidden p-3 text-center text-gray-500 text-sm">
                            <i class="fas fa-spinner fa-spin mr-2"></i>Loading...
                        </div>
                        <ul id="best-of-suggestions-list" class="">
                            <!-- Best of suggestions populated by JS -->
                        </ul>
                    </div>
                </div>

                <button id="search-button" class="pro-button w-full sm:w-1/4 py-2 px-4 text-sm rounded-lg">
                    <i class="fas fa-search"></i>Search
                </button>

                <!-- Search History Button -->
                <div class="relative">
                    <button id="history-button" class="pro-button secondary py-2 px-3 text-sm rounded-lg"
                        title="Search History">
                        <i class="fas fa-history"></i>
                    </button>
                    <!-- Search History Dropdown -->
                    <div id="search-history-dropdown"
                        class="absolute top-full right-0 w-80 pro-card mt-1 rounded-lg shadow-lg z-50 max-h-60 overflow-y-auto hidden">
                        <div class="p-3 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Recent Searches</span>
                                <button id="clear-history-button"
                                    class="text-xs text-red-600 hover:text-red-800 transition-colors">
                                    <i class="fas fa-trash mr-1"></i>Clear
                                </button>
                            </div>
                        </div>
                        <div id="search-history-list" class="p-2">
                            <!-- History items populated by JS -->
                        </div>
                        <div id="no-search-history" class="text-center text-gray-500 py-8 hidden">
                            <i class="fas fa-search text-2xl mb-2 text-gray-300"></i>
                            <p class="text-sm">No recent searches</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <p class="text-center text-xs text-gray-500 mt-2">
            <i class="fas fa-info-circle mr-1"></i> Data comes from MusicBrainz APIs.
        </p>
    </div>

    <!-- Main Application with 3 Columns -->
    <div id="app" class="pro-card w-full max-w-7xl flex flex-col md:flex-row h-[80vh] overflow-hidden">

        <!-- Favorites Menu (overlay) -->
        <div id="favorites-overlay"
            class="fixed inset-0 bg-black bg-opacity-60 z-50 hidden flex items-center justify-center p-4">
            <div class="pro-card w-full max-w-4xl max-h-[80vh] flex flex-col">
                <div class="flex items-center justify-between p-4 border-b border-gray-200">
                    <h2 class="text-lg font-semibold flex items-center">
                        <i class="fas fa-heart text-red-500 mr-2"></i>Your Favorites
                    </h2>
                    <button id="close-favorites" class="text-gray-500 hover:text-gray-700 text-lg transition-colors">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="flex-1 overflow-y-auto p-4">
                    <div id="favorites-list">
                        <!-- Favorites list populated by JS -->
                    </div>
                    <div id="no-favorites" class="text-center text-gray-500 py-16 hidden">
                        <i class="fas fa-heart text-4xl mb-3 text-gray-300"></i>
                        <p class="text-base mb-1">No favorites yet</p>
                        <p class="text-sm">Add your favorite songs by clicking the hearts!</p>
                    </div>
                </div>
            </div>
        </div> <!-- Favorites Menu -->
        <div id="favorites-menu" class="favorites-menu hidden">
            <div class="favorites-menu-item" id="export-favorites">
                <i class="fas fa-download"></i>
                <span>Esporta Preferiti</span>
            </div>
            <div class="favorites-menu-item" id="import-favorites">
                <i class="fas fa-upload"></i>
                <span>Importa Preferiti</span>
            </div>
            <div style="border-top: 1px solid rgba(229, 231, 235, 0.5); margin: 0.5rem 0;"></div>
            <div class="favorites-menu-item" id="github-repo">
                <i class="fab fa-github"></i>
                <span>Repository GitHub</span>
            </div>
        </div>

        <!-- Hidden file input for import -->
        <input type="file" id="import-file-input" accept=".json" style="display: none;">

        <!-- Column 1: Artist List -->
        <div class="w-full md:w-1/3 column-panel column-panel--tint scrollable-column">
            <div class="column-header">
                <h2 class="column-title">Artists</h2>
            </div>
            <ul id="artist-list" class="p-3 space-y-3">
                <!-- Artists populated by JS -->
                <li id="related-artists-section" class="related-section hidden">
                    <div class="related-header">
                        <h3 class="related-title">
                            <i class="fas fa-link text-blue-600"></i>
                            Similar Artists
                        </h3>
                    </div>
                    <div id="loading-related" class="hidden text-center text-gray-400 py-3 empty-state">
                        <i class="fas fa-spinner fa-spin text-xl"></i>
                    </div>
                    <ul id="related-artists-list" class="related-list">
                        <!-- Related artists populated by JS -->
                    </ul>
                    <div id="no-related-artists" class="text-center text-gray-400 text-sm py-3 empty-state">
                        <p>No similar artists found.</p>
                    </div>
                </li>
            </ul>
            <div id="loading-artists" class="hidden text-center text-gray-500 mt-20 empty-state">
                <i class="fas fa-spinner fa-spin text-4xl mb-4 empty-icon"></i>
                <p>Loading artists...</p>
            </div>
            <div id="no-artists-found" class="hidden text-center text-gray-500 mt-20 empty-state">
                <i class="fas fa-info-circle text-4xl mb-4 empty-icon"></i>
                <p>No artists found.</p>
            </div>
            
        </div>

        <!-- Column 2: Albums List -->
        <div class="w-full md:w-1/3 column-panel column-panel--tint-2 scrollable-column">
            <div class="column-header">
                <h2 id="albums-title" class="column-title">Albums</h2>
            </div>
            <ul id="album-list" class="p-3 space-y-3">
                <!-- Albums populated by JS -->
            </ul>
            <div id="no-artist-selected" class="text-center text-gray-500 mt-20 empty-state">
                <i class="fas fa-user text-6xl mb-4 empty-icon"></i>
                <p>Select an artist.</p>
            </div>
        </div>

        <!-- Column 3: Tracks List -->
        <div class="w-full md:w-1/3 column-panel column-panel--last scrollable-column">
            <div class="column-header">
                <h2 id="tracks-title" class="column-title">Tracks</h2>
            </div>
            <ul id="track-list" class="space-y-3 p-4">
                <!-- Tracks populated by JS -->
            </ul>
            <div id="no-album-selected" class="text-center text-gray-500 mt-20 empty-state">
                <i class="fas fa-compact-disc text-6xl mb-4 empty-icon"></i>
                <p>Select an album.</p>
            </div>
        </div>

        <!-- Floating Message Box -->
        <div id="message-box"
            class="fixed bottom-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 pointer-events-none z-50">
            Example message
        </div>
    </div>

    <script>
        // Function to show a temporary message
        function showMessage(text) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = text;
            messageBox.classList.remove('opacity-0');
            messageBox.classList.add('opacity-100');
            messageBox.classList.remove('pointer-events-none');
            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
                messageBox.classList.add('pointer-events-none');
            }, 3000);
        }

        // DOM Elements
        const artistSearchEl = document.getElementById('artist-search');
        const trackSearchEl = document.getElementById('track-search');
        const genreSelectEl = document.getElementById('genre-select');
        const moodSelectEl = document.getElementById('mood-select');
        const bestOfSearchEl = document.getElementById('best-of-search');
        const searchButtonEl = document.getElementById('search-button');
        const artistSearchContainerEl = document.getElementById('artist-search-container');
        const trackSearchContainerEl = document.getElementById('track-search-container');
        const genreSearchContainerEl = document.getElementById('genre-search-container');
        const moodSearchContainerEl = document.getElementById('mood-search-container');
        const bestOfSearchContainerEl = document.getElementById('best-of-search-container');
        const artistListEl = document.getElementById('artist-list');
        const albumListEl = document.getElementById('album-list');
        const trackListEl = document.getElementById('track-list');
        const albumsTitleEl = document.getElementById('albums-title');
        const tracksTitleEl = document.getElementById('tracks-title');
        const noArtistsFoundEl = document.getElementById('no-artists-found');
        const loadingArtistsEl = document.getElementById('loading-artists');
        const noArtistSelectedEl = document.getElementById('no-artist-selected');
        const noAlbumSelectedEl = document.getElementById('no-album-selected');

        // Elements for suggestions
        const searchSuggestionsEl = document.getElementById('search-suggestions');
        const suggestionsListEl = document.getElementById('suggestions-list');
        const suggestionsLoadingEl = document.getElementById('suggestions-loading');

        // Elements for track suggestions
        const trackSuggestionsEl = document.getElementById('track-suggestions');
        const trackSuggestionsListEl = document.getElementById('track-suggestions-list');
        const trackSuggestionsLoadingEl = document.getElementById('track-suggestions-loading');

        // Elements for best of suggestions
        const bestOfSuggestionsEl = document.getElementById('best-of-suggestions');
        const bestOfSuggestionsListEl = document.getElementById('best-of-suggestions-list');
        const bestOfSuggestionsLoadingEl = document.getElementById('best-of-suggestions-loading');

        // Variables for suggestion control
        let suggestionTimeout;
        let trackSuggestionTimeout;
        let bestOfSuggestionTimeout;
        let currentSuggestionIndex = -1;
        let currentTrackSuggestionIndex = -1;
        let currentBestOfSuggestionIndex = -1;
        let currentSuggestions = [];
        let currentTrackSuggestions = [];
        let currentBestOfSuggestions = [];

        // Variables for favorites
        let favorites = [];
        let currentArtistName = '';
        let currentAlbumName = '';

        // Variables for search history
        let searchHistory = [];
        const MAX_SEARCH_HISTORY = 12;

        // Variables for theme
        let currentTheme = 'dark';

        // Variables for random song
        let isGettingRandomSong = false;

        // Variables for related artists
        let currentArtistId = '';

        // DOM elements for favorites
        const favoritesButtonEl = document.getElementById('favorites-button');
        const favoritesOverlayEl = document.getElementById('favorites-overlay');
        const closeFavoritesEl = document.getElementById('close-favorites');
        const favoritesListEl = document.getElementById('favorites-list');
        const noFavoritesEl = document.getElementById('no-favorites');
        const favoritesCountEl = document.getElementById('favorites-count');

        // DOM elements for favorites menu
        const favoritesMenuToggleEl = document.getElementById('favorites-menu-toggle');
        const favoritesMenuEl = document.getElementById('favorites-menu');
        const exportFavoritesEl = document.getElementById('export-favorites');
        const importFavoritesEl = document.getElementById('import-favorites');
        const importFileInputEl = document.getElementById('import-file-input');
        const githubRepoEl = document.getElementById('github-repo');

        // Popular music genres
        const musicGenres = [
            'rock', 'pop', 'jazz', 'blues', 'classical', 'electronic', 'metal', 'punk',
            'folk', 'country', 'hip hop', 'reggae', 'funk', 'soul', 'r&b', 'disco',
            'alternative rock', 'indie', 'progressive rock', 'hard rock', 'grunge',
            'techno', 'house', 'ambient', 'experimental', 'post-rock', 'shoegaze',
            'garage rock', 'psychedelic', 'new wave', 'synthpop'
        ];

        // Popular music moods
        const musicMoods = [
            'happy', 'sad', 'energetic', 'calm', 'romantic', 'aggressive', 'melancholic',
            'uplifting', 'dark', 'bright', 'mysterious', 'nostalgic', 'dreamy', 'intense',
            'peaceful', 'anxious', 'confident', 'lonely', 'powerful', 'gentle', 'dramatic',
            'playful', 'serious', 'hopeful', 'angry', 'relaxed', 'emotional', 'triumphant',
            'ethereal', 'gritty'
        ];

        // === RANDOM SONG FUNCTIONALITY ===

        // Get a random song from MusicBrainz
        async function getRandomSong() {
            if (isGettingRandomSong) return;

            isGettingRandomSong = true;
            const randomBtn = document.getElementById('random-song-btn');
            const originalContent = randomBtn.innerHTML;

            try {
                // Show loading state
                randomBtn.classList.add('loading');
                randomBtn.innerHTML = '<i class="fas fa-spinner"></i><span>Finding...</span>';
                randomBtn.style.pointerEvents = 'none';

                // Select a random genre
                const randomGenre = musicGenres[Math.floor(Math.random() * musicGenres.length)];

                // Search for artists in that genre
                showMessage(`Searching for ${randomGenre} artists...`);
                const artistResponse = await fetch(
                    `${musicBrainzApiUrl}artist?query=tag:${encodeURIComponent(randomGenre)}&fmt=json&limit=50`,
                    { headers: { 'User-Agent': userAgent } }
                );

                if (!artistResponse.ok) throw new Error('Failed to fetch artists');
                const artistData = await artistResponse.json();

                if (!artistData.artists || artistData.artists.length === 0) {
                    throw new Error('No artists found for genre');
                }

                // Select random artist
                const randomArtist = artistData.artists[Math.floor(Math.random() * artistData.artists.length)];

                // Update UI message
                randomBtn.innerHTML = '<i class="fas fa-spinner"></i><span>Loading albums...</span>';
                showMessage(`Found ${randomArtist.name}, loading albums...`);

                // Get albums for the artist
                const albumResponse = await fetch(
                    `${musicBrainzApiUrl}release-group?artist=${randomArtist.id}&fmt=json&type=album&limit=20`,
                    { headers: { 'User-Agent': userAgent } }
                );

                if (!albumResponse.ok) throw new Error('Failed to fetch albums');
                const albumData = await albumResponse.json();

                if (!albumData['release-groups'] || albumData['release-groups'].length === 0) {
                    throw new Error('No albums found for artist');
                }

                // Select random album
                const randomAlbum = albumData['release-groups'][Math.floor(Math.random() * albumData['release-groups'].length)];

                // Update UI message
                randomBtn.innerHTML = '<i class="fas fa-spinner"></i><span>Loading tracks...</span>';
                showMessage(`Loading tracks from "${randomAlbum.title}"...`);

                // Get tracks for the album
                const trackResponse = await fetch(
                    `${musicBrainzApiUrl}release?release-group=${randomAlbum.id}&fmt=json&inc=recordings&status=official&limit=1`,
                    { headers: { 'User-Agent': userAgent } }
                );

                if (!trackResponse.ok) throw new Error('Failed to fetch tracks');
                const trackData = await trackResponse.json();

                if (!trackData.releases || trackData.releases.length === 0 ||
                    !trackData.releases[0].media || trackData.releases[0].media.length === 0 ||
                    !trackData.releases[0].media[0].tracks || trackData.releases[0].media[0].tracks.length === 0) {
                    throw new Error('No tracks found for album');
                }

                const tracks = trackData.releases[0].media[0].tracks;
                const randomTrack = tracks[Math.floor(Math.random() * tracks.length)];

                // Show success state
                randomBtn.innerHTML = '<i class="fas fa-check"></i><span>Found!</span>';
                randomBtn.style.background = 'rgba(34, 197, 94, 0.9)';

                // Update the UI to show the random selection
                updateUIWithRandomSelection(randomArtist, randomAlbum, randomTrack);

                // Show success message
                showMessage(`Random song: "${randomTrack.title}" by ${randomArtist.name} from "${randomAlbum.title}"`);

            } catch (error) {
                console.error('Error getting random song:', error);
                randomBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>Try again</span>';
                randomBtn.style.background = 'rgba(239, 68, 68, 0.9)';
                showMessage('Error finding random song. Please try again.');
            } finally {
                // Reset button after 3 seconds
                setTimeout(() => {
                    randomBtn.innerHTML = originalContent;
                    randomBtn.style.background = '';
                    randomBtn.style.pointerEvents = 'auto';
                    randomBtn.classList.remove('loading');
                    isGettingRandomSong = false;
                }, 3000);
            }
        }

        // Update UI with random selection
        function updateUIWithRandomSelection(artist, album, track) {
            // Clear current selections
            artistListEl.innerHTML = '';
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';

            // Set current names
            currentArtistName = artist.name;
            currentAlbumName = album.title;

            // Create and display the random artist
            const artistItem = document.createElement('li');
            artistItem.className = 'list-item flex items-center justify-between active-item';
            artistItem.innerHTML = `
                <div>
                    <span class="font-medium text-gray-900">${artist.name}</span>
                    <div class="text-sm text-blue-600 flex items-center mt-1">
                        <i class="fas fa-random mr-1"></i>Random Selection
                    </div>
                </div>
            `;
            artistListEl.appendChild(artistItem);

            // Update titles
            albumsTitleEl.textContent = `Albums by ${artist.name}`;
            tracksTitleEl.textContent = `Tracks from ${album.title}`;

            // Show the selected states
            noArtistSelectedEl.style.display = 'none';
            noAlbumSelectedEl.style.display = 'none';

            // Simulate loading albums and tracks
            setTimeout(() => {
                // Add the random album
                const albumItem = document.createElement('li');
                albumItem.className = 'list-item active-item';
                albumItem.innerHTML = `
                    <div>
                        <span class="font-medium text-gray-900">${album.title}</span>
                        <div class="text-sm text-green-600 flex items-center mt-1">
                            <i class="fas fa-random mr-1"></i>Random Album
                        </div>
                    </div>
                `;
                albumListEl.appendChild(albumItem);

                // Add the random track
                setTimeout(() => {
                    const isFavorite = isTrackFavorite(track.title, artist.name, album.title);
                    const trackItem = document.createElement('li');
                    trackItem.className = 'track-item list-item flex items-center justify-between';
                    trackItem.innerHTML = `
                        <div class="flex items-center space-x-3 flex-1 min-w-0">
                            <div class="min-w-0 flex-1">
                                <span class="text-gray-900 font-medium text-sm block truncate" title="${track.title}">${track.title}</span>
                                <div class="text-xs text-yellow-600 flex items-center">
                                    <i class="fas fa-random mr-1"></i>Random Track
                                </div>
                            </div>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openSongsterr('${track.title.replace(/'/g, "\\'")}', '${artist.name.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="Songsterr Tabs">
                                <i class="fas fa-guitar text-blue-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openYoutubeTutorial('${artist.name.replace(/'/g, "\\'")}', '${track.title.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="YouTube Tutorial">
                                <i class="fab fa-youtube text-red-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openYoutubeBackingTrack('${artist.name.replace(/'/g, "\\'")}', '${track.title.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="YouTube Backing Track">
                                <i class="fab fa-youtube text-red-500 text-sm"></i>
                                <i class="fas fa-music text-blue-400 text-xs ml-1"></i>
                                <span style="font-size:10px;margin-left:2px;">BT</span>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openUltimateGuitar('${track.title.replace(/'/g, "\\'")}', '${artist.name.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="Ultimate Guitar Tabs">
                                <i class="fas fa-music text-orange-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="toggleFavorite('${track.title.replace(/'/g, "\\'")}', '${artist.name.replace(/'/g, "\\'")}', '${album.title.replace(/'/g, "\\'")}', this)" 
                                    title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
                                <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'} text-sm"></i>
                            </button>
                        </div>
                    `;
                    trackListEl.appendChild(trackItem);
                }, 500);
            }, 300);
        }

        // === SEARCH HISTORY MANAGEMENT ===

        // Load search history from localStorage
        function loadSearchHistory() {
            try {
                const saved = localStorage.getItem('musicapp-search-history');
                searchHistory = saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.error('Error loading search history:', error);
                searchHistory = [];
            }
        }

        // Save search history to localStorage
        function saveSearchHistory() {
            try {
                localStorage.setItem('musicapp-search-history', JSON.stringify(searchHistory));
            } catch (error) {
                console.error('Error saving search history:', error);
            }
        }

        // Add search to history
        function addToSearchHistory(type, query) {
            if (!query || query.trim().length < 2) return;

            const searchItem = {
                type: type,
                query: query.trim(),
                timestamp: new Date().toISOString(),
                displayName: getSearchDisplayName(type, query.trim())
            };

            // Remove duplicates (same type and query)
            searchHistory = searchHistory.filter(item =>
                !(item.type === type && item.query.toLowerCase() === query.toLowerCase())
            );

            // Add to beginning
            searchHistory.unshift(searchItem);

            // Limit to MAX_SEARCH_HISTORY items
            if (searchHistory.length > MAX_SEARCH_HISTORY) {
                searchHistory = searchHistory.slice(0, MAX_SEARCH_HISTORY);
            }

            saveSearchHistory();
        }

        // Get display name for search item
        function getSearchDisplayName(type, query) {
            switch (type) {
                case 'artist':
                    return `Artist: ${query}`;
                case 'track':
                    return `Track: ${query}`;
                case 'genre':
                    return `Genre: ${query}`;
                case 'mood':
                    return `Mood: ${query}`;
                case 'best-of':
                    return `Best of: ${query}`;
                default:
                    return query;
            }
        }

        // Show search history dropdown
        function showSearchHistory() {
            renderSearchHistory();
            document.getElementById('search-history-dropdown').classList.remove('hidden');
        }

        // Hide search history dropdown
        function hideSearchHistory() {
            document.getElementById('search-history-dropdown').classList.add('hidden');
        }

        // Render search history list
        function renderSearchHistory() {
            const historyListEl = document.getElementById('search-history-list');
            const noHistoryEl = document.getElementById('no-search-history');

            if (searchHistory.length === 0) {
                historyListEl.innerHTML = '';
                noHistoryEl.classList.remove('hidden');
                return;
            }

            noHistoryEl.classList.add('hidden');

            let html = '';
            searchHistory.forEach((item, index) => {
                const timeAgo = getTimeAgo(new Date(item.timestamp));
                const typeIcon = getSearchTypeIcon(item.type);

                html += `
                    <div class="history-item flex items-center justify-between p-2 rounded hover:bg-gray-100 cursor-pointer transition-colors" 
                         data-type="${item.type}" data-query="${item.query.replace(/"/g, '&quot;')}">
                        <div class="flex items-center space-x-3 flex-1 min-w-0">
                            <i class="${typeIcon} text-sm flex-shrink-0"></i>
                            <div class="min-w-0 flex-1">
                                <div class="text-sm font-medium text-gray-900 truncate">${item.query}</div>
                                <div class="text-xs text-gray-500">${item.type}  ${timeAgo}</div>
                            </div>
                        </div>
                        <button class="remove-history-item text-gray-400 hover:text-red-500 p-1 transition-colors" 
                                data-index="${index}" title="Remove from history">
                            <i class="fas fa-times text-xs"></i>
                        </button>
                    </div>
                `;
            });

            historyListEl.innerHTML = html;

            // Add event listeners for history items
            historyListEl.querySelectorAll('.history-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.closest('.remove-history-item')) return;

                    const type = item.dataset.type;
                    const query = item.dataset.query;
                    applyHistorySearch(type, query);
                });
            });

            // Add event listeners for remove buttons
            historyListEl.querySelectorAll('.remove-history-item').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(btn.dataset.index);
                    removeHistoryItem(index);
                });
            });
        }

        // Get icon for search type
        function getSearchTypeIcon(type) {
            switch (type) {
                case 'artist':
                    return 'fas fa-user text-blue-500';
                case 'track':
                    return 'fas fa-play-circle text-green-500';
                case 'genre':
                    return 'fas fa-music text-purple-500';
                case 'mood':
                    return 'fas fa-heart text-pink-500';
                case 'best-of':
                    return 'fas fa-star text-yellow-500';
                default:
                    return 'fas fa-search text-gray-500';
            }
        }

        // Get time ago string
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Apply history search
        function applyHistorySearch(type, query) {
            // Set the correct search type
            document.querySelector(`input[name="search-type"][value="${type}"]`).checked = true;
            handleSearchTypeChange();

            // Set the query in the appropriate field
            if (type === 'artist') {
                artistSearchEl.value = query;
                hideSuggestions();
                searchArtists(query);
            } else if (type === 'track') {
                trackSearchEl.value = query;
                hideTrackSuggestions();
                searchTracks(query);
            } else if (type === 'genre') {
                genreSelectEl.value = query;
                searchArtistsByGenre(query);
            } else if (type === 'mood') {
                moodSelectEl.value = query;
                searchArtistsByMood(query);
            } else if (type === 'best-of') {
                bestOfSearchEl.value = query;
                hideBestOfSuggestions();
                searchArtistBestOf(query);
            }

            hideSearchHistory();
            showMessage(`Applied search: ${getSearchDisplayName(type, query)}`);
        }

        // Remove history item
        function removeHistoryItem(index) {
            searchHistory.splice(index, 1);
            saveSearchHistory();
            renderSearchHistory();
            showMessage('Search removed from history');
        }

        // Clear all search history
        function clearSearchHistory() {
            if (searchHistory.length === 0) {
                showMessage('Search history is already empty');
                return;
            }

            if (confirm(`Clear all ${searchHistory.length} search history items?`)) {
                searchHistory = [];
                saveSearchHistory();
                renderSearchHistory();
                showMessage('Search history cleared');
            }
        }

        // Load saved theme
        function loadTheme() {
            try {
                const savedTheme = localStorage.getItem('musicapp-theme');
                currentTheme = savedTheme || 'dark';
                applyTheme(currentTheme);
                updateThemeSelector();
            } catch (error) {
                console.error('Error loading theme:', error);
                currentTheme = 'dark';
                applyTheme('dark');
            }
        }

        // Apply theme
        function applyTheme(theme) {
            const body = document.body;
            if (theme === 'dark') {
                body.classList.add('dark-theme');
            } else {
                body.classList.remove('dark-theme');
            }
            currentTheme = theme;
            saveTheme();
        }

        // Save theme
        function saveTheme() {
            try {
                localStorage.setItem('musicapp-theme', currentTheme);
            } catch (error) {
                console.error('Error saving theme:', error);
            }
        }

        // Update theme selector
        function updateThemeSelector() {
            document.querySelectorAll('.theme-option').forEach(option => {
                const theme = option.getAttribute('data-theme');
                if (theme === currentTheme) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        // Change theme
        function changeTheme(theme) {
            if (theme !== currentTheme) {
                applyTheme(theme);
                updateThemeSelector();

                const themeName = theme === 'dark' ? 'dark' : 'light';
                showMessage(`${themeName} theme activated`);
            }
        }

        // === FAVORITES MANAGEMENT ===

        // Load favorites from localStorage
        function loadFavorites() {
            try {
                const saved = localStorage.getItem('musicapp-favorites');
                favorites = saved ? JSON.parse(saved) : [];
                updateFavoritesCount();
            } catch (error) {
                console.error('Error loading favorites:', error);
                favorites = [];
            }
        }

        // Save favorites to localStorage
        function saveFavorites() {
            try {
                localStorage.setItem('musicapp-favorites', JSON.stringify(favorites));
                updateFavoritesCount();
            } catch (error) {
                console.error('Error saving favorites:', error);
                showMessage('Error saving favorites');
            }
        }

        // Update favorites counter
        function updateFavoritesCount() {
            favoritesCountEl.textContent = favorites.length;
        }

        // Check if a track is in favorites
        function isTrackFavorite(trackTitle, artist, album) {
            return favorites.some(fav =>
                fav.title === trackTitle &&
                fav.artist === artist &&
                fav.album === album
            );
        }

        // Add/remove a track from favorites
        function toggleFavorite(trackTitle, artist, album, buttonEl) {
            const favoriteIndex = favorites.findIndex(fav =>
                fav.title === trackTitle &&
                fav.artist === artist &&
                fav.album === album
            );

            const heartIcon = buttonEl.querySelector('i');

            if (favoriteIndex === -1) {
                // Add to favorites
                const favorite = {
                    title: trackTitle,
                    artist: artist,
                    album: album,
                    dateAdded: new Date().toISOString()
                };
                favorites.push(favorite);
                heartIcon.classList.remove('text-gray-400');
                heartIcon.classList.add('text-red-500');
                buttonEl.title = 'Remove from favorites';
                showMessage(`"${trackTitle}" added to favorites!`);
            } else {
                // Remove from favorites
                favorites.splice(favoriteIndex, 1);
                heartIcon.classList.remove('text-red-500');
                heartIcon.classList.add('text-gray-400');
                buttonEl.title = 'Add to favorites';
                showMessage(`"${trackTitle}" removed from favorites`);
            }

            saveFavorites();
        }

        // Get current artist name
        function getCurrentArtistName() {
            return currentArtistName;
        }

        // Get current album name
        function getCurrentAlbumName() {
            return currentAlbumName;
        }

        // Show favorites window
        function showFavorites() {
            renderFavoritesList();
            favoritesOverlayEl.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent page scrolling
        }

        // Hide favorites window
        function hideFavorites() {
            favoritesOverlayEl.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        // Render favorites list
        function renderFavoritesList() {
            if (favorites.length === 0) {
                favoritesListEl.innerHTML = '';
                noFavoritesEl.classList.remove('hidden');
                return;
            }

            noFavoritesEl.classList.add('hidden');

            // Group by artist
            const groupedFavorites = favorites.reduce((groups, favorite) => {
                const artist = favorite.artist;
                if (!groups[artist]) {
                    groups[artist] = {};
                }
                const album = favorite.album;
                if (!groups[artist][album]) {
                    groups[artist][album] = [];
                }
                groups[artist][album].push(favorite);
                return groups;
            }, {});

            let html = '';
            Object.keys(groupedFavorites).forEach(artist => {
                html += `<div class="mb-4">
                    <h3 class="text-base font-semibold text-gray-800 mb-2 flex items-center">
                        <i class="fas fa-user mr-2 text-blue-500 text-sm"></i>${artist}
                    </h3>`;

                Object.keys(groupedFavorites[artist]).forEach(album => {
                    html += `<div class="ml-3 mb-3">
                        <h4 class="text-sm font-medium text-gray-700 mb-1 flex items-center">
                            <i class="fas fa-compact-disc mr-1 text-green-500 text-xs"></i>${album}
                        </h4>
                        <div class="ml-3 space-y-1">`;

                    groupedFavorites[artist][album].forEach(favorite => {
                        html += `<div class="flex items-center justify-between p-2 bg-gray-50 rounded hover:bg-gray-100 transition-colors">
                            <div class="flex items-center space-x-2 flex-1 min-w-0">
                                <div class="flex-1 min-w-0">
                                    <span class="text-gray-800 text-sm font-medium truncate" title="${favorite.title}">${favorite.title}</span>
                                </div>
                                <button class="pro-button secondary p-1 rounded text-xs flex-shrink-0" 
                                        onclick="openSongsterr('${favorite.title.replace(/'/g, "\\'")}', '${artist.replace(/'/g, "\\'")}'); event.stopPropagation();"
                                        title="Songsterr Tabs">
                                    <i class="fas fa-guitar text-blue-500 text-xs"></i>
                                </button>
                                <button class="pro-button secondary p-1 rounded text-xs flex-shrink-0" 
                                        onclick="openYoutubeTutorial('${artist.replace(/'/g, "\\'")}', '${favorite.title.replace(/'/g, "\\'")}'); event.stopPropagation();"
                                        title="YouTube Tutorial">
                                    <i class="fab fa-youtube text-red-500 text-xs"></i>
                                </button>
                                <button class="pro-button secondary p-1 rounded text-xs flex-shrink-0" 
                                        onclick="openUltimateGuitar('${favorite.title.replace(/'/g, "\\'")}', '${artist.replace(/'/g, "\\'")}'); event.stopPropagation();"
                                        title="Ultimate Guitar Tabs">
                                    <i class="fas fa-music text-orange-500 text-xs"></i>
                                </button>
                                <button class="pro-button secondary p-1 rounded text-xs flex-shrink-0" 
                                        onclick="removeFavoriteFromList('${favorite.title.replace(/'/g, "\\'")}', '${artist.replace(/'/g, "\\'")}', '${album.replace(/'/g, "\\'")}')"
                                        title="Remove from favorites">
                                    <i class="fas fa-trash-alt text-red-500 text-xs"></i>
                                </button>
                            </div>
                        </div>`;
                    });

                    html += '</div></div>';
                });

                html += '</div>';
            });

            favoritesListEl.innerHTML = html;
        }

        // Remove a favorite from the list
        function removeFavoriteFromList(trackTitle, artist, album) {
            const favoriteIndex = favorites.findIndex(fav =>
                fav.title === trackTitle &&
                fav.artist === artist &&
                fav.album === album
            );

            if (favoriteIndex !== -1) {
                favorites.splice(favoriteIndex, 1);
                saveFavorites();
                renderFavoritesList();
                showMessage(`"${trackTitle}" removed from favorites`);

                // Also update the icon in the tracks list if visible
                const currentTrackButtons = document.querySelectorAll('.favorite-btn');
                currentTrackButtons.forEach(btn => {
                    const onclick = btn.getAttribute('onclick');
                    if (onclick && onclick.includes(trackTitle)) {
                        const heartIcon = btn.querySelector('i');
                        heartIcon.classList.remove('text-red-500');
                        heartIcon.classList.add('text-gray-400');
                        btn.title = 'Add to favorites';
                    }
                });
            }
        }

        // === FAVORITES MENU FUNCTIONS ===

        // Toggle favorites menu visibility
        function toggleFavoritesMenu() {
            favoritesMenuEl.classList.toggle('hidden');
        }

        // Hide favorites menu
        function hideFavoritesMenu() {
            favoritesMenuEl.classList.add('hidden');
        }

        // Export favorites to JSON file
        function exportFavorites() {
            try {
                if (favorites.length === 0) {
                    showMessage('No favorites to export!');
                    return;
                }

                const dataStr = JSON.stringify(favorites, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });

                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `musicbrainz-favorites-${new Date().toISOString().split('T')[0]}.json`;

                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Clean up the blob URL
                URL.revokeObjectURL(link.href);

                showMessage(`${favorites.length} favorites exported successfully!`);
                hideFavoritesMenu();

            } catch (error) {
                console.error('Error exporting favorites:', error);
                showMessage('Error exporting favorites. Please try again.');
            }
        }

        // Import favorites from JSON file
        function importFavorites() {
            importFileInputEl.click();
        }

        // Handle file import
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Validate the imported data
                    if (!Array.isArray(importedData)) {
                        throw new Error('Invalid file format: expected an array');
                    }

                    // Validate each favorite item
                    const validFavorites = importedData.filter(item => {
                        return item &&
                            typeof item.title === 'string' &&
                            typeof item.artist === 'string' &&
                            typeof item.album === 'string';
                    });

                    if (validFavorites.length === 0) {
                        throw new Error('No valid favorites found in file');
                    }

                    // Ask user if they want to replace or merge
                    const shouldReplace = confirm(`Found ${validFavorites.length} favorites in file.\n\nClick OK to REPLACE current favorites (${favorites.length})\nClick Cancel to MERGE with current favorites`);

                    let importedCount = 0;

                    if (shouldReplace) {
                        // Replace all favorites
                        favorites = validFavorites.map(fav => ({
                            ...fav,
                            dateAdded: fav.dateAdded || new Date().toISOString()
                        }));
                        importedCount = favorites.length;
                    } else {
                        // Merge favorites (avoid duplicates)
                        validFavorites.forEach(newFav => {
                            const exists = favorites.some(existingFav =>
                                existingFav.title === newFav.title &&
                                existingFav.artist === newFav.artist &&
                                existingFav.album === newFav.album
                            );

                            if (!exists) {
                                favorites.push({
                                    ...newFav,
                                    dateAdded: newFav.dateAdded || new Date().toISOString()
                                });
                                importedCount++;
                            }
                        });
                    }

                    saveFavorites();
                    hideFavoritesMenu();

                    if (importedCount > 0) {
                        showMessage(`Successfully imported ${importedCount} favorites!`);
                    } else {
                        showMessage('No new favorites were imported (all already existed)');
                    }

                } catch (error) {
                    console.error('Error importing favorites:', error);
                    showMessage('Error importing file. Please check the file format.');
                }
            };

            reader.onerror = function () {
                showMessage('Error reading file. Please try again.');
            };

            reader.readAsText(file);

            // Reset the input
            event.target.value = '';
        }

        // Open GitHub repository
        function openGitHubRepo() {
            const repoUrl = 'https://github.com/numbor/musicbrainz2songsterr';
            window.open(repoUrl, '_blank');
            showMessage('Opening GitHub repository...');
            hideFavoritesMenu();
        }

        // Base URL for MusicBrainz APIs
        const musicBrainzApiUrl = 'https://musicbrainz.org/ws/2/';
        const userAgent = 'SongsterrPlayerApp/1.0.0 (andrea.rossi@example.com)';

        // Initialize music genres in the dropdown
        function initializeGenres() {
            musicGenres.forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre.charAt(0).toUpperCase() + genre.slice(1);
                genreSelectEl.appendChild(option);
            });
        }

        // Initialize music moods in the dropdown
        function initializeMoods() {
            musicMoods.forEach(mood => {
                const option = document.createElement('option');
                option.value = mood;
                option.textContent = mood.charAt(0).toUpperCase() + mood.slice(1);
                moodSelectEl.appendChild(option);
            });
        }

        // Handle search type change
        function handleSearchTypeChange() {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;

            // Hide all containers first
            artistSearchContainerEl.classList.add('hidden');
            trackSearchContainerEl.classList.add('hidden');
            genreSearchContainerEl.classList.add('hidden');
            moodSearchContainerEl.classList.add('hidden');
            bestOfSearchContainerEl.classList.add('hidden');
            hideSuggestions();
            hideTrackSuggestions();
            hideBestOfSuggestions();

            // Show the selected container
            if (searchType === 'artist') {
                artistSearchContainerEl.classList.remove('hidden');
            } else if (searchType === 'track') {
                trackSearchContainerEl.classList.remove('hidden');
            } else if (searchType === 'genre') {
                genreSearchContainerEl.classList.remove('hidden');
            } else if (searchType === 'mood') {
                moodSearchContainerEl.classList.remove('hidden');
            } else if (searchType === 'best-of') {
                bestOfSearchContainerEl.classList.remove('hidden');
            }
        }

        // Function to search artists by genre
        async function searchArtistsByGenre(genre) {
            loadingArtistsEl.classList.remove('hidden');
            noArtistsFoundEl.classList.add('hidden');
            artistListEl.innerHTML = '';
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';
            albumsTitleEl.textContent = 'Albums';
            tracksTitleEl.textContent = 'Tracks';
            noArtistSelectedEl.style.display = 'block';
            noAlbumSelectedEl.style.display = 'block';

            try {
                // Search for artists with the specified genre tag
                const url = `${musicBrainzApiUrl}artist?query=tag:${encodeURIComponent(genre)}&fmt=json&limit=50`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const artists = data.artists || [];

                if (artists.length > 0) {
                    renderArtists(artists);
                    showMessage(`Found ${artists.length} artists for genre "${genre}"`);
                } else {
                    noArtistsFoundEl.classList.remove('hidden');
                    showMessage(`No artists found for genre "${genre}"`);
                }
            } catch (error) {
                console.error('API call failed:', error);
                noArtistsFoundEl.classList.remove('hidden');
                showMessage('Error while searching by genre.');
            } finally {
                loadingArtistsEl.classList.add('hidden');
            }
        }

        // Function to search artists by mood
        async function searchArtistsByMood(mood) {
            loadingArtistsEl.classList.remove('hidden');
            noArtistsFoundEl.classList.add('hidden');
            artistListEl.innerHTML = '';
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';
            albumsTitleEl.textContent = 'Albums';
            tracksTitleEl.textContent = 'Tracks';
            noArtistSelectedEl.style.display = 'block';
            noAlbumSelectedEl.style.display = 'block';

            try {
                // Search for artists with the specified mood tag
                const url = `${musicBrainzApiUrl}artist?query=tag:${encodeURIComponent(mood)}&fmt=json&limit=50`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const artists = data.artists || [];

                if (artists.length > 0) {
                    renderArtists(artists);
                    showMessage(`Found ${artists.length} artists for mood "${mood}"`);
                } else {
                    noArtistsFoundEl.classList.remove('hidden');
                    showMessage(`No artists found for mood "${mood}"`);
                }
            } catch (error) {
                console.error('API call failed:', error);
                noArtistsFoundEl.classList.remove('hidden');
                showMessage('Error while searching by mood.');
            } finally {
                loadingArtistsEl.classList.add('hidden');
            }
        }

        // Function to show/hide suggestions
        function showSuggestions() {
            searchSuggestionsEl.classList.remove('hidden');
        }

        function hideSuggestions() {
            searchSuggestionsEl.classList.add('hidden');
            currentSuggestionIndex = -1;
            currentSuggestions = [];
        }

        // Function to show/hide track suggestions
        function showTrackSuggestions() {
            trackSuggestionsEl.classList.remove('hidden');
        }

        function hideTrackSuggestions() {
            trackSuggestionsEl.classList.add('hidden');
            currentTrackSuggestionIndex = -1;
            currentTrackSuggestions = [];
        }

        // Function to show/hide best of suggestions
        function showBestOfSuggestions() {
            bestOfSuggestionsEl.classList.remove('hidden');
        }

        function hideBestOfSuggestions() {
            bestOfSuggestionsEl.classList.add('hidden');
            currentBestOfSuggestionIndex = -1;
            currentBestOfSuggestions = [];
        }

        // Function to get real-time best of suggestions
        async function fetchBestOfSuggestions(query) {
            if (query.length < 2) {
                hideBestOfSuggestions();
                return;
            }

            bestOfSuggestionsLoadingEl.classList.remove('hidden');
            bestOfSuggestionsListEl.innerHTML = '';
            showBestOfSuggestions();

            try {
                const url = `${musicBrainzApiUrl}artist?query=${encodeURIComponent(query)}&fmt=json&limit=8`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const artists = data.artists || [];

                bestOfSuggestionsLoadingEl.classList.add('hidden');

                if (artists.length > 0) {
                    renderBestOfSuggestions(artists);
                } else {
                    bestOfSuggestionsListEl.innerHTML = '<li class="p-4 text-gray-500 text-center">No artists found</li>';
                }

            } catch (error) {
                console.error('Best of suggestion API call failed:', error);
                bestOfSuggestionsLoadingEl.classList.add('hidden');
                bestOfSuggestionsListEl.innerHTML = '<li class="p-4 text-red-500 text-center">Loading error</li>';
            }
        }

        // Function to render best of suggestions
        function renderBestOfSuggestions(artists) {
            currentBestOfSuggestions = artists;
            bestOfSuggestionsListEl.innerHTML = '';

            artists.forEach((artist, index) => {
                const li = document.createElement('li');
                li.className = 'suggestion-item flex items-center justify-between';

                // Get artist area/country info
                let areaInfo = '';
                if (artist.area && artist.area.name) {
                    areaInfo = `  ${artist.area.name}`;
                } else if (artist['begin-area'] && artist['begin-area'].name) {
                    areaInfo = `  ${artist['begin-area'].name}`;
                }

                li.innerHTML = `
                    <div class="flex-1 p-3 cursor-pointer hover:bg-gray-50 transition-colors" 
                         onclick="selectBestOfSuggestion('${artist.name.replace(/'/g, "\\'")}', '${artist.id}')">
                        <div class="font-medium text-gray-900 text-sm">${artist.name}</div>
                        <div class="text-xs text-gray-500">
                            <span class="capitalize">${artist.type || 'Artist'}</span>${areaInfo}
                        </div>
                    </div>
                `;

                bestOfSuggestionsListEl.appendChild(li);
            });
        }

        // Function to select a best of suggestion
        function selectBestOfSuggestion(artistName, artistId) {
            bestOfSearchEl.value = artistName;
            hideBestOfSuggestions();
            searchArtistBestOf(artistName, artistId);
        }

        // Function to highlight a best of suggestion
        function highlightBestOfSuggestion(index) {
            document.querySelectorAll('#best-of-suggestions .suggestion-item').forEach((item, i) => {
                item.classList.toggle('highlighted', i === index);
            });
            currentBestOfSuggestionIndex = index;
        }
        async function fetchTrackSuggestions(query) {
            if (query.length < 2) {
                hideTrackSuggestions();
                return;
            }

            trackSuggestionsLoadingEl.classList.remove('hidden');
            trackSuggestionsListEl.innerHTML = '';
            showTrackSuggestions();

            try {
                const url = `${musicBrainzApiUrl}recording?query=${encodeURIComponent(query)}&fmt=json&limit=8`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const tracks = data.recordings || [];

                trackSuggestionsLoadingEl.classList.add('hidden');

                if (tracks.length > 0) {
                    renderTrackSuggestions(tracks);
                } else {
                    trackSuggestionsListEl.innerHTML = '<li class="p-4 text-gray-500 text-center">No tracks found</li>';
                }

            } catch (error) {
                console.error('Track suggestion API call failed:', error);
                trackSuggestionsLoadingEl.classList.add('hidden');
                trackSuggestionsListEl.innerHTML = '<li class="p-4 text-red-500 text-center">Loading error</li>';
            }
        }

        // Function to render track suggestions
        function renderTrackSuggestions(tracks) {
            currentTrackSuggestions = tracks;
            trackSuggestionsListEl.innerHTML = '';

            tracks.forEach((track, index) => {
                const li = document.createElement('li');
                li.className = 'suggestion-item flex items-center justify-between';

                // Get artist name from artist-credit
                const artistName = track['artist-credit'] && track['artist-credit'][0]
                    ? track['artist-credit'][0].name
                    : 'Unknown Artist';

                li.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-medium text-gray-900">${track.title}</span>
                        <div class="flex items-center text-sm text-gray-500">
                            <i class="fas fa-user mr-1 text-xs"></i>
                            <span>${artistName}</span>
                            ${track.length ? `<span class="mx-2"></span><span>${Math.floor(track.length / 60000)}:${String(Math.floor((track.length % 60000) / 1000)).padStart(2, '0')}</span>` : ''}
                        </div>
                    </div>
                    <i class="fas fa-arrow-right text-gray-400"></i>
                `;

                li.addEventListener('click', () => {
                    selectTrackSuggestion(track);
                });

                li.addEventListener('mouseenter', () => {
                    highlightTrackSuggestion(index);
                });

                trackSuggestionsListEl.appendChild(li);
            });
        }

        // Function to select a track suggestion
        function selectTrackSuggestion(track) {
            trackSearchEl.value = track.title;
            hideTrackSuggestions();
            searchTracks(track.title);
        }

        // Function to highlight a track suggestion
        function highlightTrackSuggestion(index) {
            document.querySelectorAll('#track-suggestions .suggestion-item').forEach((item, i) => {
                item.classList.toggle('highlighted', i === index);
            });
            currentTrackSuggestionIndex = index;
        }

        // Function to search artist's best/most popular songs
        async function searchArtistBestOf(artistName, artistId = null) {
            loadingArtistsEl.classList.remove('hidden');
            noArtistsFoundEl.classList.add('hidden');
            artistListEl.innerHTML = '';
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';
            albumsTitleEl.textContent = 'Albums';
            tracksTitleEl.textContent = `Best of ${artistName}`;
            noArtistSelectedEl.style.display = 'none';
            noAlbumSelectedEl.style.display = 'none';

            try {
                let searchArtistId = artistId;

                // If no artistId provided, search for the artist first
                if (!searchArtistId) {
                    const artistResponse = await fetch(
                        `${musicBrainzApiUrl}artist?query=${encodeURIComponent(artistName)}&fmt=json&limit=1`,
                        { headers: { 'User-Agent': userAgent } }
                    );
                    if (!artistResponse.ok) throw new Error('Failed to find artist');

                    const artistData = await artistResponse.json();
                    if (!artistData.artists || artistData.artists.length === 0) {
                        throw new Error('Artist not found');
                    }
                    searchArtistId = artistData.artists[0].id;
                }

                // Step 1: Get the most important/popular releases (albums, compilations, greatest hits)
                showMessage(`Searching for ${artistName}'s most popular releases...`);
                const releasesResponse = await fetch(
                    `${musicBrainzApiUrl}release-group?artist=${searchArtistId}&fmt=json&type=album|compilation&limit=50`,
                    { headers: { 'User-Agent': userAgent } }
                );
                if (!releasesResponse.ok) throw new Error('Failed to fetch releases');

                const releasesData = await releasesResponse.json();
                let releaseGroups = releasesData['release-groups'] || [];

                // Prioritize greatest hits, best of, compilation albums
                const bestOfKeywords = ['greatest hits', 'best of', 'essential', 'collection', 'gold', 'platinum', 'hits', 'anthology', 'complete'];
                const priorityReleases = releaseGroups.filter(release => {
                    const title = release.title.toLowerCase();
                    return bestOfKeywords.some(keyword => title.includes(keyword));
                });

                // If we have best-of albums, use those first, otherwise use regular albums
                const targetReleases = priorityReleases.length > 0 ? priorityReleases.slice(0, 3) : releaseGroups.slice(0, 10);

                let allTracks = [];
                let trackPopularityMap = new Map();

                // Step 2: Get tracks from the most important releases
                for (const releaseGroup of targetReleases) {
                    try {
                        const tracksResponse = await fetch(
                            `${musicBrainzApiUrl}release?release-group=${releaseGroup.id}&fmt=json&inc=recordings&status=official&limit=1`,
                            { headers: { 'User-Agent': userAgent } }
                        );

                        if (tracksResponse.ok) {
                            const tracksData = await tracksResponse.json();
                            const releases = tracksData.releases || [];

                            if (releases.length > 0 && releases[0].media && releases[0].media.length > 0) {
                                const tracks = releases[0].media[0].tracks || [];

                                tracks.forEach(track => {
                                    if (track.title && track.title.length > 1) {
                                        const normalizedTitle = track.title.toLowerCase().trim();

                                        // Count how many times this track appears (popularity indicator)
                                        if (trackPopularityMap.has(normalizedTitle)) {
                                            trackPopularityMap.set(normalizedTitle, trackPopularityMap.get(normalizedTitle) + 1);
                                        } else {
                                            trackPopularityMap.set(normalizedTitle, 1);
                                            allTracks.push({
                                                ...track,
                                                sourceAlbum: releaseGroup.title,
                                                isFromBestOf: bestOfKeywords.some(keyword => releaseGroup.title.toLowerCase().includes(keyword))
                                            });
                                        }
                                    }
                                });
                            }
                        }
                    } catch (error) {
                        console.log(`Error fetching tracks for ${releaseGroup.title}:`, error);
                    }
                }

                // Step 3: If we don't have enough tracks, supplement with direct recording search
                if (allTracks.length < 10) {
                    try {
                        const recordingsResponse = await fetch(
                            `${musicBrainzApiUrl}recording?artist=${searchArtistId}&fmt=json&limit=30`,
                            { headers: { 'User-Agent': userAgent } }
                        );

                        if (recordingsResponse.ok) {
                            const recordingsData = await recordingsResponse.json();
                            const recordings = recordingsData.recordings || [];

                            recordings.forEach(recording => {
                                const normalizedTitle = recording.title.toLowerCase().trim();
                                if (!trackPopularityMap.has(normalizedTitle)) {
                                    trackPopularityMap.set(normalizedTitle, 1);
                                    allTracks.push({
                                        ...recording,
                                        sourceAlbum: 'Singles & Other Recordings',
                                        isFromBestOf: false
                                    });
                                }
                            });
                        }
                    } catch (error) {
                        console.log('Error fetching additional recordings:', error);
                    }
                }

                if (allTracks.length === 0) {
                    trackListEl.innerHTML = `
                        <div class="text-center text-gray-500 mt-20">
                            <i class="fas fa-music text-4xl mb-4 text-gray-300"></i>
                            <p>No popular songs found for ${artistName}</p>
                            <p class="text-sm mt-2">Try searching by artist instead</p>
                        </div>
                    `;
                    loadingArtistsEl.classList.add('hidden');
                    return;
                }

                // Step 4: Sort tracks by popularity indicators
                allTracks = allTracks.sort((a, b) => {
                    const aTitle = a.title.toLowerCase().trim();
                    const bTitle = b.title.toLowerCase().trim();

                    // Prioritize tracks from "best of" albums
                    if (a.isFromBestOf !== b.isFromBestOf) {
                        return b.isFromBestOf - a.isFromBestOf;
                    }

                    // Then by appearance count
                    const aCount = trackPopularityMap.get(aTitle) || 1;
                    const bCount = trackPopularityMap.get(bTitle) || 1;
                    if (bCount !== aCount) return bCount - aCount;

                    // Prefer tracks with more releases
                    const aReleases = a['release-count'] || 0;
                    const bReleases = b['release-count'] || 0;
                    if (bReleases !== aReleases) return bReleases - aReleases;

                    // Finally, prefer shorter titles (often more recognizable)
                    return a.title.length - b.title.length;
                });

                // Remove duplicates and take top 15-20
                const uniqueTracks = [];
                const seenTitles = new Set();

                for (const track of allTracks) {
                    const normalizedTitle = track.title.toLowerCase().trim();
                    if (!seenTitles.has(normalizedTitle)) {
                        seenTitles.add(normalizedTitle);
                        uniqueTracks.push(track);
                        if (uniqueTracks.length >= 20) break;
                    }
                }

                // Render the best of results
                renderBestOfResults(uniqueTracks, artistName, trackPopularityMap);
                showMessage(`Found ${uniqueTracks.length} popular songs by ${artistName}`);

                // Add to search history
                addToSearchHistory('best-of', artistName);

            } catch (error) {
                console.error('API call failed:', error);
                trackListEl.innerHTML = `
                    <div class="text-center text-gray-500 mt-20">
                        <i class="fas fa-exclamation-triangle text-4xl mb-4 text-red-300"></i>
                        <p>Error loading best songs for ${artistName}</p>
                        <p class="text-sm mt-2">Please try again</p>
                    </div>
                `;
                showMessage('Error while searching for best songs.');
            } finally {
                loadingArtistsEl.classList.add('hidden');
            }
        }

        // Render Best Of Results in Tracks Column
        function renderBestOfResults(recordings, artistName, popularityMap = new Map()) {
            trackListEl.innerHTML = '';

            recordings.forEach((recording, index) => {
                const isFavorite = isTrackFavorite(recording.title, artistName, 'Best of');

                // Get popularity indicators
                const normalizedTitle = recording.title.toLowerCase().trim();
                const appearances = popularityMap.get(normalizedTitle) || 1;
                const releaseCount = recording['release-count'] || 0;

                // Determine source info
                let sourceInfo = recording.sourceAlbum || 'Popular Track';
                let sourceClass = 'text-gray-500';
                let sourceIcon = 'fas fa-star';

                if (recording.isFromBestOf) {
                    sourceClass = 'text-yellow-600';
                    sourceIcon = 'fas fa-trophy';
                    sourceInfo = `From: ${recording.sourceAlbum}`;
                } else if (appearances > 1) {
                    sourceClass = 'text-green-600';
                    sourceIcon = 'fas fa-fire';
                    sourceInfo = `Appears in ${appearances} albums`;
                } else if (releaseCount > 0) {
                    sourceClass = 'text-blue-600';
                    sourceIcon = 'fas fa-compact-disc';
                    sourceInfo = `${releaseCount} releases`;
                }

                const trackItem = document.createElement('li');
                trackItem.className = 'track-item list-item flex items-center justify-between';
                trackItem.innerHTML = `
                    <div class="flex items-center space-x-3 flex-1 min-w-0">
                        <div class="min-w-0 flex-1">
                            <span class="text-gray-900 font-semibold text-sm block truncate" title="${recording.title}">
                                <span class="text-yellow-600 font-bold mr-2 w-6 inline-block text-right">#${index + 1}</span>${recording.title}
                            </span>
                            <div class="text-xs ${sourceClass} flex items-center mt-1">
                                <i class="${sourceIcon} mr-1"></i>${sourceInfo}
                                ${recording.isFromBestOf ? '  Greatest Hits' : ''}
                            </div>
                        </div>
                        <div class="flex items-center space-x-1">
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openSongsterr('${recording.title.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${artistName.replace(/'/g, "\\'").replace(/"/g, '&quot;')}'); event.stopPropagation();" 
                                    title="Songsterr Tabs">
                                <i class="fas fa-guitar text-blue-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openYoutubeTutorial('${artistName.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${recording.title.replace(/'/g, "\\'").replace(/"/g, '&quot;')}'); event.stopPropagation();" 
                                    title="YouTube Tutorial">
                                <i class="fab fa-youtube text-red-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openYoutubeBackingTrack('${artistName.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${recording.title.replace(/'/g, "\\'").replace(/"/g, '&quot;')}'); event.stopPropagation();" 
                                    title="YouTube Backing Track">
                                <i class="fab fa-youtube text-red-500 text-sm"></i>
                                <i class="fas fa-music text-blue-400 text-xs ml-1"></i>
                                <span style="font-size:10px;margin-left:2px;">BT</span>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openUltimateGuitar('${recording.title.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${artistName.replace(/'/g, "\\'").replace(/"/g, '&quot;')}'); event.stopPropagation();" 
                                    title="Ultimate Guitar Tabs">
                                <i class="fas fa-music text-orange-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0 favorite-btn" 
                                    onclick="toggleFavorite('${recording.title.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${artistName.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', 'Best of', this)" 
                                    title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
                                <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'} text-sm"></i>
                            </button>
                        </div>
                    </div>
                `;
                trackListEl.appendChild(trackItem);
            });

            // Add a small note at the bottom
            if (recordings.length > 0) {
                const noteDiv = document.createElement('div');
                noteDiv.className = 'text-center text-xs text-gray-400 mt-4 p-3 bg-gray-50 rounded';
                noteDiv.innerHTML = `
                    <i class="fas fa-info-circle mr-1"></i>
                    Songs ranked by appearances in compilations, greatest hits albums, and release frequency
                `;
                trackListEl.appendChild(noteDiv);
            }
        }
        async function searchTracks(query) {
            loadingArtistsEl.classList.remove('hidden');
            noArtistsFoundEl.classList.add('hidden');
            artistListEl.innerHTML = '';
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';
            albumsTitleEl.textContent = 'Albums';
            tracksTitleEl.textContent = 'Loading...';
            noArtistSelectedEl.style.display = 'none';
            noAlbumSelectedEl.style.display = 'none';

            try {
                // Search for recordings (tracks) with artist information
                const url = `${musicBrainzApiUrl}recording?query=${encodeURIComponent(query)}&fmt=json&inc=artist-credits+releases&limit=50`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const tracks = data.recordings || [];

                if (tracks.length > 0) {
                    renderTrackResults(tracks, query);
                    showMessage(`Found ${tracks.length} tracks matching "${query}"`);
                } else {
                    tracksTitleEl.textContent = `No results for "${query}"`;
                    trackListEl.innerHTML = '<div class="text-center text-gray-500 py-16"><i class="fas fa-search text-4xl mb-3 text-gray-300"></i><p class="text-base mb-1">No tracks found</p><p class="text-sm">Try a different search query</p></div>';
                    showMessage(`No tracks found for "${query}"`);
                }
            } catch (error) {
                console.error('Track search API call failed:', error);
                tracksTitleEl.textContent = 'Search error';
                trackListEl.innerHTML = '<div class="text-center text-red-500 py-16"><i class="fas fa-exclamation-triangle text-4xl mb-3"></i><p class="text-base mb-1">Search failed</p><p class="text-sm">Please try again</p></div>';
                showMessage('Error while searching for tracks.');
            } finally {
                loadingArtistsEl.classList.add('hidden');
            }
        }

        // Render Track Results in Tracks Column
        function renderTrackResults(tracks, query) {
            tracksTitleEl.textContent = `Search results for "${query}"`;
            trackListEl.innerHTML = '';

            // Set info message for first two columns
            artistListEl.innerHTML = '<div class="text-center text-gray-500 mt-20"><i class="fas fa-search text-6xl mb-4 text-gray-300"></i><p class="text-lg font-medium mb-2">Track Search Mode</p><p class="text-sm">Results are shown in the Tracks column </p></div>';
            albumListEl.innerHTML = '<div class="text-center text-gray-500 mt-20"><i class="fas fa-arrow-right text-6xl mb-4 text-gray-300"></i><p class="text-lg font-medium mb-2">Direct to Tracks</p><p class="text-sm">Browse results in the next column </p></div>';

            // Group tracks by artist for better organization
            const tracksByArtist = {};
            tracks.forEach(track => {
                const artistName = track['artist-credit'] && track['artist-credit'][0]
                    ? track['artist-credit'][0].name
                    : 'Unknown Artist';

                if (!tracksByArtist[artistName]) {
                    tracksByArtist[artistName] = [];
                }
                tracksByArtist[artistName].push(track);
            });

            // Render grouped results in tracks column
            Object.keys(tracksByArtist).forEach((artistName, artistIndex) => {
                const artistTracks = tracksByArtist[artistName];

                // Create artist header (collapsible)
                const artistHeader = document.createElement('div');
                artistHeader.className = 'mb-3';

                const artistHeaderButton = document.createElement('button');
                artistHeaderButton.className = 'w-full text-left';
                artistHeaderButton.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-2">
                            <i class="fas fa-user text-blue-600 text-sm"></i>
                            <span class="font-semibold text-gray-900">${artistName}</span>
                            <span class="text-sm bg-blue-200 text-blue-800 px-2 py-0.5 rounded-full">${artistTracks.length} track${artistTracks.length > 1 ? 's' : ''}</span>
                        </div>
                        <i class="fas fa-chevron-down text-blue-600 transition-transform duration-200" id="toggle-artist-${artistIndex}"></i>
                    </div>
                `;

                const tracksContainer = document.createElement('div');
                tracksContainer.className = 'mt-2 space-y-2';
                tracksContainer.id = `tracks-container-${artistIndex}`;

                artistTracks.forEach((track, trackIndex) => {
                    // Get album name from releases
                    let albumName = 'Unknown Album';
                    if (track.releases && track.releases.length > 0) {
                        albumName = track.releases[0].title;
                    }

                    const trackDuration = track.length ?
                        `${Math.floor(track.length / 60000)}:${String(Math.floor((track.length % 60000) / 1000)).padStart(2, '0')}` : '';

                    const isFavorite = isTrackFavorite(track.title, artistName, albumName);

                    const trackItem = document.createElement('div');
                    trackItem.className = 'track-item list-item ml-4';

                    trackItem.innerHTML = `
                        <div class="flex items-center space-x-3">
                            <div class="flex-1 min-w-0">
                                <div class="text-gray-900 font-medium text-sm truncate" title="${track.title}">${track.title}</div>
                                <div class="flex items-center text-xs text-gray-500 mt-1">
                                    <i class="fas fa-compact-disc mr-1"></i>
                                    <span class="truncate">${albumName}</span>
                                    ${trackDuration ? `<span class="mx-2"></span><span class="font-mono">${trackDuration}</span>` : ''}
                                </div>
                            </div>
                            <div class="flex items-center space-x-2 flex-shrink-0">
                                <button class="pro-button secondary p-2 rounded-lg text-xs hover:bg-blue-50 hover:border-blue-200 transition-colors" 
                                        onclick="openSongsterr('${track.title.replace(/'/g, "\\'")}', '${artistName.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                        title="Songsterr Tabs">
                                    <i class="fas fa-guitar text-blue-500 text-sm"></i>
                                </button>
                                <button class="pro-button secondary p-2 rounded-lg text-xs hover:bg-red-50 hover:border-red-200 transition-colors" 
                                        onclick="openYoutubeTutorial('${artistName.replace(/'/g, "\\'")}', '${track.title.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                        title="YouTube Tutorial">
                                    <i class="fab fa-youtube text-red-500 text-sm"></i>
                                </button>
                                <button class="pro-button secondary p-2 rounded-lg text-xs hover:bg-blue-50 hover:border-blue-200 transition-colors" 
                                        onclick="openYoutubeBackingTrack('${artistName.replace(/'/g, "\\'")}', '${track.title.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                        title="YouTube Backing Track">
                                    <i class="fab fa-youtube text-red-500 text-sm"></i>
                                    <i class="fas fa-music text-blue-400 text-xs ml-1"></i>
                                    <span style="font-size:10px;margin-left:2px;">BT</span>
                                </button>
                                <button class="pro-button secondary p-2 rounded-lg text-xs hover:bg-orange-50 hover:border-orange-200 transition-colors" 
                                        onclick="openUltimateGuitar('${track.title.replace(/'/g, "\\'")}', '${artistName.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                        title="Ultimate Guitar Tabs">
                                    <i class="fas fa-music text-orange-500 text-sm"></i>
                                </button>
                                <button class="pro-button secondary p-2 rounded-lg text-xs hover:bg-pink-50 hover:border-pink-200 transition-colors" 
                                        onclick="toggleFavorite('${track.title.replace(/'/g, "\\'")}', '${artistName.replace(/'/g, "\\'")}', '${albumName.replace(/'/g, "\\'")}', this)" 
                                        title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
                                    <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'} text-sm hover:text-red-500"></i>
                                </button>
                            </div>
                        </div>
                    `;

                    tracksContainer.appendChild(trackItem);
                });

                // Add click event to toggle tracks visibility
                let isExpanded = true; // Start expanded
                artistHeaderButton.addEventListener('click', () => {
                    const toggleIcon = artistHeaderButton.querySelector(`#toggle-artist-${artistIndex}`);

                    if (isExpanded) {
                        tracksContainer.style.display = 'none';
                        toggleIcon.classList.remove('fa-chevron-down');
                        toggleIcon.classList.add('fa-chevron-right');
                        toggleIcon.style.transform = 'rotate(0deg)';
                        isExpanded = false;
                    } else {
                        tracksContainer.style.display = 'block';
                        toggleIcon.classList.remove('fa-chevron-right');
                        toggleIcon.classList.add('fa-chevron-down');
                        toggleIcon.style.transform = 'rotate(0deg)';
                        isExpanded = true;
                    }
                });

                artistHeader.appendChild(artistHeaderButton);
                artistHeader.appendChild(tracksContainer);
                trackListEl.appendChild(artistHeader);
            });
        }

        // Function to get real-time suggestions
        async function fetchSuggestions(query) {
            if (query.length < 2) {
                hideSuggestions();
                return;
            }

            suggestionsLoadingEl.classList.remove('hidden');
            suggestionsListEl.innerHTML = '';
            showSuggestions();

            try {
                const url = `${musicBrainzApiUrl}artist?query=${encodeURIComponent(query)}&fmt=json&limit=8`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const artists = data.artists || [];

                suggestionsLoadingEl.classList.add('hidden');

                if (artists.length > 0) {
                    renderSuggestions(artists);
                } else {
                    suggestionsListEl.innerHTML = '<li class="p-4 text-gray-500 text-center">No artists found</li>';
                }

            } catch (error) {
                console.error('Suggestion API call failed:', error);
                suggestionsLoadingEl.classList.add('hidden');
                suggestionsListEl.innerHTML = '<li class="p-4 text-red-500 text-center">Loading error</li>';
            }
        }

        // Function to render suggestions
        function renderSuggestions(artists) {
            currentSuggestions = artists;
            suggestionsListEl.innerHTML = '';

            artists.forEach((artist, index) => {
                const li = document.createElement('li');
                li.className = 'suggestion-item flex items-center justify-between';
                li.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-medium text-gray-900">${artist.name}</span>
                        ${artist.disambiguation ? `<span class="text-sm text-gray-500">${artist.disambiguation}</span>` : ''}
                    </div>
                    <i class="fas fa-arrow-right text-gray-400"></i>
                `;

                li.addEventListener('click', () => {
                    selectSuggestion(artist);
                });

                li.addEventListener('mouseenter', () => {
                    highlightSuggestion(index);
                });

                suggestionsListEl.appendChild(li);
            });
        }

        // Function to select a suggestion
        function selectSuggestion(artist) {
            artistSearchEl.value = artist.name;
            hideSuggestions();
            searchArtists(artist.name);
        }

        // Function to highlight a suggestion
        function highlightSuggestion(index) {
            document.querySelectorAll('.suggestion-item').forEach((item, i) => {
                item.classList.toggle('highlighted', i === index);
            });
            currentSuggestionIndex = index;
        }

        // Handle keyboard navigation
        function handleKeyNavigation(e) {
            const suggestions = document.querySelectorAll('#search-suggestions .suggestion-item');

            if (suggestions.length === 0) return;

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    currentSuggestionIndex = Math.min(currentSuggestionIndex + 1, suggestions.length - 1);
                    highlightSuggestion(currentSuggestionIndex);
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    currentSuggestionIndex = Math.max(currentSuggestionIndex - 1, -1);
                    if (currentSuggestionIndex >= 0) {
                        highlightSuggestion(currentSuggestionIndex);
                    } else {
                        document.querySelectorAll('#search-suggestions .suggestion-item').forEach(item => {
                            item.classList.remove('highlighted');
                        });
                    }
                    break;

                case 'Enter':
                    e.preventDefault();
                    if (currentSuggestionIndex >= 0 && currentSuggestions[currentSuggestionIndex]) {
                        selectSuggestion(currentSuggestions[currentSuggestionIndex]);
                    } else {
                        searchButtonEl.click();
                    }
                    break;

                case 'Escape':
                    hideSuggestions();
                    break;
            }
        }

        // Handle keyboard navigation for tracks
        function handleTrackKeyNavigation(e) {
            const suggestions = document.querySelectorAll('#track-suggestions .suggestion-item');

            if (suggestions.length === 0) return;

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    currentTrackSuggestionIndex = Math.min(currentTrackSuggestionIndex + 1, suggestions.length - 1);
                    highlightTrackSuggestion(currentTrackSuggestionIndex);
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    currentTrackSuggestionIndex = Math.max(currentTrackSuggestionIndex - 1, -1);
                    if (currentTrackSuggestionIndex >= 0) {
                        highlightTrackSuggestion(currentTrackSuggestionIndex);
                    } else {
                        document.querySelectorAll('#track-suggestions .suggestion-item').forEach(item => {
                            item.classList.remove('highlighted');
                        });
                    }
                    break;

                case 'Enter':
                    e.preventDefault();
                    if (currentTrackSuggestionIndex >= 0 && currentTrackSuggestions[currentTrackSuggestionIndex]) {
                        selectTrackSuggestion(currentTrackSuggestions[currentTrackSuggestionIndex]);
                    } else {
                        searchButtonEl.click();
                    }
                    break;

                case 'Escape':
                    hideTrackSuggestions();
                    break;
            }
        }

        // Handle keyboard navigation for best-of
        function handleBestOfKeyNavigation(e) {
            const suggestions = document.querySelectorAll('#best-of-suggestions .suggestion-item');

            if (suggestions.length === 0) return;

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    currentBestOfSuggestionIndex = Math.min(currentBestOfSuggestionIndex + 1, suggestions.length - 1);
                    highlightBestOfSuggestion(currentBestOfSuggestionIndex);
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    currentBestOfSuggestionIndex = Math.max(currentBestOfSuggestionIndex - 1, -1);
                    if (currentBestOfSuggestionIndex >= 0) {
                        highlightBestOfSuggestion(currentBestOfSuggestionIndex);
                    } else {
                        document.querySelectorAll('#best-of-suggestions .suggestion-item').forEach(item => {
                            item.classList.remove('highlighted');
                        });
                    }
                    break;

                case 'Enter':
                    e.preventDefault();
                    if (currentBestOfSuggestionIndex >= 0 && currentBestOfSuggestions[currentBestOfSuggestionIndex]) {
                        selectBestOfSuggestion(currentBestOfSuggestions[currentBestOfSuggestionIndex].name, currentBestOfSuggestions[currentBestOfSuggestionIndex].id);
                    } else {
                        searchButtonEl.click();
                    }
                    break;

                case 'Escape':
                    hideBestOfSuggestions();
                    break;
            }
        }

        // Function to search artists via MusicBrainz
        async function searchArtists(query) {
            loadingArtistsEl.classList.remove('hidden');
            noArtistsFoundEl.classList.add('hidden');
            artistListEl.innerHTML = '';
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';
            albumsTitleEl.textContent = 'Albums';
            tracksTitleEl.textContent = 'Tracks';
            noArtistSelectedEl.style.display = 'block';
            noAlbumSelectedEl.style.display = 'block';

            try {
                // Build URL for artist search
                const url = `${musicBrainzApiUrl}artist?query=${encodeURIComponent(query)}&fmt=json`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const artists = data.artists || [];

                if (artists.length > 0) {
                    renderArtists(artists);
                } else {
                    noArtistsFoundEl.classList.remove('hidden');
                }
            } catch (error) {
                console.error('API call failed:', error);
                noArtistsFoundEl.classList.remove('hidden');
                showMessage('Error while searching for artists.');
            } finally {
                loadingArtistsEl.classList.add('hidden');
            }
        }

        // Main search function that determines the type
        function performSearch() {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;

            if (searchType === 'artist') {
                const artistName = artistSearchEl.value.trim();
                if (artistName) {
                    hideSuggestions();
                    addToSearchHistory('artist', artistName);
                    searchArtists(artistName);
                } else {
                    showMessage("Enter an artist name to search.");
                }
            } else if (searchType === 'track') {
                const trackName = trackSearchEl.value.trim();
                if (trackName) {
                    hideTrackSuggestions();
                    addToSearchHistory('track', trackName);
                    searchTracks(trackName);
                } else {
                    showMessage("Enter a track name to search.");
                }
            } else if (searchType === 'genre') {
                const selectedGenre = genreSelectEl.value;
                if (selectedGenre) {
                    addToSearchHistory('genre', selectedGenre);
                    searchArtistsByGenre(selectedGenre);
                } else {
                    showMessage("Select a genre to search.");
                }
            } else if (searchType === 'mood') {
                const selectedMood = moodSelectEl.value;
                if (selectedMood) {
                    addToSearchHistory('mood', selectedMood);
                    searchArtistsByMood(selectedMood);
                } else {
                    showMessage("Select a mood to search.");
                }
            } else if (searchType === 'best-of') {
                const artistName = bestOfSearchEl.value.trim();
                if (artistName) {
                    hideBestOfSuggestions();
                    addToSearchHistory('best-of', artistName);
                    searchArtistBestOf(artistName);
                } else {
                    showMessage("Enter an artist name to search for best songs.");
                }
            }
        }

        // Function to get an artist's albums via MusicBrainz
        async function getArtistAlbums(artistId, artistName) {
            albumListEl.innerHTML = '';
            trackListEl.innerHTML = '';
            albumsTitleEl.textContent = 'Loading...';
            tracksTitleEl.textContent = 'Tracks';
            noArtistSelectedEl.style.display = 'none';
            noAlbumSelectedEl.style.display = 'block';

            try {
                // URL to get release-groups (albums) of an artist
                const url = `${musicBrainzApiUrl}release-group?artist=${artistId}&fmt=json&type=album&inc=artist-credits`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const albums = data['release-groups'] || [];

                albumsTitleEl.textContent = `Albums by ${artistName}`;

                if (albums.length > 0) {
                    renderAlbums(albums);
                } else {
                    albumListEl.innerHTML = '<p class="text-center text-gray-500 mt-20">No albums found.</p>';
                }

            } catch (error) {
                console.error('API call failed:', error);
                albumsTitleEl.textContent = 'Loading error';
                showMessage('Error while loading albums.');
            }
        }

        // Function to get album tracks via MusicBrainz
        async function getAlbumTracks(releaseGroupId, albumTitle) {
            trackListEl.innerHTML = '';
            tracksTitleEl.textContent = 'Loading...';
            noAlbumSelectedEl.style.display = 'none';

            try {
                // Find the first "release" ID for the release-group,
                // because only releases contain the track list (recordings).
                const releasesUrl = `${musicBrainzApiUrl}release?release-group=${releaseGroupId}&fmt=json&inc=recordings&status=official`;
                const releasesResponse = await fetch(releasesUrl, {
                    headers: { 'User-Agent': userAgent }
                });
                if (!releasesResponse.ok) throw new Error('Network response for releases was not ok');

                const releasesData = await releasesResponse.json();
                const releases = releasesData.releases || [];

                if (releases.length > 0 && releases[0].media && releases[0].media.length > 0) {
                    const tracks = releases[0].media[0].tracks;
                    tracksTitleEl.textContent = `Tracks from ${albumTitle}`;
                    renderTracks(tracks);
                } else {
                    tracksTitleEl.textContent = `Tracks from ${albumTitle}`;
                    trackListEl.innerHTML = '<p class="text-center text-gray-500 mt-20">No tracks found for this album.</p>';
                }
            } catch (error) {
                console.error('API call failed:', error);
                tracksTitleEl.textContent = 'Loading error';
                showMessage('Error while loading tracks.');
            }
        }

        // Function to get related artists via MusicBrainz
        async function getRelatedArtists(artistId, artistName) {
            console.log('Fetching related artists for:', artistName, artistId);
            const relatedSection = document.getElementById('related-artists-section');
            const loadingRelated = document.getElementById('loading-related');
            const relatedList = document.getElementById('related-artists-list');
            const noRelated = document.getElementById('no-related-artists');

            // Show section and loading state
            relatedSection.classList.remove('hidden');
            loadingRelated.classList.remove('hidden');
            relatedList.innerHTML = '';
            noRelated.classList.add('hidden');

            try {
                // First try: get artist relationships (member-of, collaboration, etc.)
                const url = `${musicBrainzApiUrl}artist/${artistId}?fmt=json&inc=relationships`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': userAgent }
                });

                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const relationships = data.relationships || [];
                console.log('Relationships found:', relationships.length, relationships);

                // Filter for related-artists relationships
                const relatedRelationships = relationships.filter(rel =>
                    rel['target-type'] === 'artist' && 
                    (rel.type === 'collaboration' || 
                     rel.type === 'member of' ||
                     rel.type === 'performed with')
                );

                console.log('Related relationships:', relatedRelationships);

                const artistURIs = new Set();
                const relatedArtistsMap = {};

                // Extract artist URIs from relationships
                relatedRelationships.forEach(rel => {
                    if (rel.artist && rel.artist.id && rel.artist.name) {
                        if (rel.artist.name !== artistName) {
                            relatedArtistsMap[rel.artist.id] = rel.artist.name;
                        }
                    } else if (rel.title) {
                        artistURIs.add(rel.title);
                    }
                });

                const relatedArtistsArray = Object.entries(relatedArtistsMap).map(([id, name]) => ({
                    id,
                    name
                })).slice(0, 10);

                if (relatedArtistsArray.length > 0) {
                    renderRelatedArtists(relatedArtistsArray);
                } else {
                    // Fallback: search for artists by tags
                    console.log('No direct relationships found, searching by tags...');
                    await getRelatedArtistsByGenre(artistId, artistName);
                }

            } catch (error) {
                console.error('API call failed:', error);
                // Even on error, try the fallback method
                await getRelatedArtistsByGenre(artistId, artistName);
            }
        }

        // Alternative method: get related artists by searching similar tags/genres
        async function getRelatedArtistsByGenre(artistId, artistName) {
            const relatedList = document.getElementById('related-artists-list');
            const noRelated = document.getElementById('no-related-artists');
            const loadingRelated = document.getElementById('loading-related');

            try {
                console.log('Fetching tags for artist:', artistName, artistId);

                // Get artist tags
                const tagsUrl = `${musicBrainzApiUrl}artist/${artistId}?fmt=json&inc=tags+genres`;
                const tagsResponse = await fetch(tagsUrl, {
                    headers: { 'User-Agent': userAgent }
                });

                if (!tagsResponse.ok) {
                    console.error('Tags fetch failed');
                    throw new Error('Tags fetch failed');
                }

                const tagsData = await tagsResponse.json();
                const tags = tagsData.tags || [];
                const genres = tagsData.genres || [];
                
                console.log('Tags found:', tags.length, tags);
                console.log('Genres found:', genres.length, genres);

                // Combine tags and genres
                const allTags = [...tags, ...genres];

                if (allTags.length === 0) {
                    console.log('No tags found, showing no results');
                    loadingRelated.classList.add('hidden');
                    relatedList.innerHTML = '';
                    noRelated.classList.remove('hidden');
                    return;
                }

                // Get top 2 tags with highest count
                const topTags = allTags
                    .sort((a, b) => (b.count || 0) - (a.count || 0))
                    .slice(0, 2)
                    .map(t => t.name);

                console.log('Top tags for', artistName, ':', topTags);

                if (topTags.length === 0) {
                    loadingRelated.classList.add('hidden');
                    relatedList.innerHTML = '';
                    noRelated.classList.remove('hidden');
                    return;
                }

                // Try multiple search strategies to find similar artists
                const similarArtistsSet = new Map();

                for (const tag of topTags) {
                    try {
                        // Search using tag in query
                        const searchUrl = `${musicBrainzApiUrl}artist?query=tag:"${encodeURIComponent(tag)}"&fmt=json&limit=20`;
                        console.log('Searching with tag:', tag);
                        
                        const searchResponse = await fetch(searchUrl, {
                            headers: { 'User-Agent': userAgent }
                        });

                        if (searchResponse.ok) {
                            const searchData = await searchResponse.json();
                            const foundArtists = searchData.artists || [];
                            console.log(`Found ${foundArtists.length} artists for tag "${tag}"`);

                            foundArtists.forEach(artist => {
                                if (artist.name !== artistName && artist.id && artist.name) {
                                    similarArtistsSet.set(artist.id, {
                                        id: artist.id,
                                        name: artist.name
                                    });
                                }
                            });
                        }

                        // Stop if we have enough
                        if (similarArtistsSet.size >= 10) break;

                    } catch (tagError) {
                        console.error('Error searching for tag:', tag, tagError);
                    }
                }

                const similarArtists = Array.from(similarArtistsSet.values()).slice(0, 10);

                loadingRelated.classList.add('hidden');

                console.log('Final similar artists:', similarArtists.length, similarArtists);

                if (similarArtists.length > 0) {
                    renderRelatedArtists(similarArtists);
                } else {
                    relatedList.innerHTML = '';
                    noRelated.classList.remove('hidden');
                }

            } catch (error) {
                console.error('getRelatedArtistsByGenre failed:', error);
                loadingRelated.classList.add('hidden');
                relatedList.innerHTML = '';
                noRelated.classList.remove('hidden');
            }
        }

        // Render related artists list
        function renderRelatedArtists(relatedArtists) {
            const relatedList = document.getElementById('related-artists-list');
            const noRelated = document.getElementById('no-related-artists');
            const loadingRelated = document.getElementById('loading-related');

            loadingRelated.classList.add('hidden');

            if (relatedArtists.length === 0) {
                relatedList.innerHTML = '';
                noRelated.classList.remove('hidden');
                return;
            }

            noRelated.classList.add('hidden');
            relatedList.innerHTML = '';

            relatedArtists.forEach(artist => {
                const li = document.createElement('li');
                li.className = 'list-item list-item-compact text-sm cursor-pointer';
                li.innerHTML = `
                    <span class="text-gray-800 font-medium hover:text-blue-600">${artist.name}</span>
                `;

                li.addEventListener('click', () => {
                    // Trigger search for related artist
                    artistSearchEl.value = artist.name;
                    searchArtists(artist.name);
                    showMessage(`Loading ${artist.name}...`);
                });

                relatedList.appendChild(li);
            });
        }

        // Render Artist List
        function renderArtists(artists) {
            let relatedSection = document.getElementById('related-artists-section');
            if (!relatedSection) {
                relatedSection = document.createElement('li');
                relatedSection.id = 'related-artists-section';
                relatedSection.className = 'related-section hidden';
                relatedSection.innerHTML = `
                    <div class="related-header">
                        <h3 class="related-title">
                            <i class="fas fa-link text-blue-600"></i>
                            Similar Artists
                        </h3>
                    </div>
                    <div id="loading-related" class="hidden text-center text-gray-400 py-3 empty-state">
                        <i class="fas fa-spinner fa-spin text-xl"></i>
                    </div>
                    <ul id="related-artists-list" class="related-list"></ul>
                    <div id="no-related-artists" class="text-center text-gray-400 text-sm py-3 empty-state">
                        <p>No similar artists found.</p>
                    </div>
                `;
            }
            artistListEl.innerHTML = '';
            if (relatedSection) {
                relatedSection.classList.add('hidden');
                artistListEl.appendChild(relatedSection);
            }
            artists.forEach(artist => {
                const li = document.createElement('li');
                li.className = 'list-item flex items-center justify-between';
                li.innerHTML = `<span class="font-medium text-gray-900">${artist.name}</span>`;
                li.addEventListener('click', (e) => {
                    document.querySelectorAll('#artist-list .list-item').forEach(item => {
                        item.classList.remove('active-item');
                    });
                    li.classList.add('active-item');
                    currentArtistName = artist.name; // Track current artist
                    currentArtistId = artist.id; // Track current artist ID
                    if (relatedSection) {
                        artistListEl.insertBefore(relatedSection, li.nextSibling);
                        relatedSection.classList.remove('hidden');
                    }
                    getArtistAlbums(artist.id, artist.name);
                    getRelatedArtists(artist.id, artist.name); // Fetch related artists
                });
                if (relatedSection && relatedSection.parentNode === artistListEl) {
                    artistListEl.insertBefore(li, relatedSection);
                } else {
                    artistListEl.appendChild(li);
                }
            });
        }

        // Render Albums List for a selected artist
        function renderAlbums(albums) {
            albumListEl.innerHTML = '';
            albums.forEach(album => {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.innerHTML = `<span class="font-medium text-gray-900">${album.title}</span>`;
                li.addEventListener('click', (e) => {
                    document.querySelectorAll('#album-list .list-item').forEach(item => {
                        item.classList.remove('active-item');
                    });
                    li.classList.add('active-item');
                    currentAlbumName = album.title; // Track current album
                    getAlbumTracks(album.id, album.title);
                });
                albumListEl.appendChild(li);
            });
        }

        // Render Tracks List for a selected album
        function renderTracks(tracks) {
            trackListEl.innerHTML = '';
            tracks.forEach(track => {
                const li = document.createElement('li');
                li.className = 'track-item list-item flex items-center justify-between';

                const isFavorite = isTrackFavorite(track.title, getCurrentArtistName(), getCurrentAlbumName());

                li.innerHTML = `
                    <div class="flex flex-wrap items-center gap-2 flex-1 min-w-0">
                        <div class="flex-1 min-w-0 pr-2">
                            <span class="text-gray-900 truncate text-sm font-medium" title="${track.title}">${track.title}</span>
                        </div>
                        <div class="flex flex-row flex-wrap gap-2 border-l border-gray-300 pl-2">
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openSongsterr('${track.title.replace(/'/g, "\\'")}', '${getCurrentArtistName().replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="Songsterr Tabs">
                                <i class="fas fa-guitar text-blue-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openYoutubeTutorial('${getCurrentArtistName().replace(/'/g, "\\'")}', '${track.title.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="YouTube Tutorial">
                                <i class="fab fa-youtube text-red-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openYoutubeBackingTrack('${getCurrentArtistName().replace(/'/g, "\\'")}', '${track.title.replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="YouTube Backing Track">
                                <i class="fab fa-youtube text-red-500 text-sm"></i>
                                <i class="fas fa-music text-blue-400 text-xs ml-1"></i>
                                <span style="font-size:10px;margin-left:2px;">BT</span>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="openUltimateGuitar('${track.title.replace(/'/g, "\\'")}', '${getCurrentArtistName().replace(/'/g, "\\'")}'); event.stopPropagation();" 
                                    title="Ultimate Guitar Tabs">
                                <i class="fas fa-music text-orange-500 text-sm"></i>
                            </button>
                            <button class="pro-button secondary p-1.5 rounded text-xs flex-shrink-0" 
                                    onclick="toggleFavorite('${track.title.replace(/'/g, "\\'")}', '${getCurrentArtistName().replace(/'/g, "\\'")}', '${getCurrentAlbumName().replace(/'/g, "\\'")}', this)" 
                                    title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
                                <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'} text-sm"></i>
                            </button>
                        </div>
                    </div>
                `;
                trackListEl.appendChild(li);
            });
        }


        // Open Songsterr URL
        function openSongsterr(title, artist) {
            const searchQuery = artist ? `${artist} ${title}` : title;
            const encodedQuery = encodeURIComponent(searchQuery);
            const url = `https://www.songsterr.com/a/wa/search?pattern=${encodedQuery}`;
            window.open(url, '_blank');
            showMessage(`Searching for "${title}" by ${artist || 'Unknown Artist'} on Songsterr...`);
        }

        // Open YouTube Tutorial
        function openYoutubeTutorial(artist, track) {
            const searchQuery = `${artist} ${track} tutorial`;
            const encodedQuery = encodeURIComponent(searchQuery);
            const youtubeUrl = `https://www.youtube.com/results?search_query=${encodedQuery}`;
            window.open(youtubeUrl, '_blank');
            showMessage(`Searching for "${track}" tutorial on YouTube...`);
        }

        // Open YouTube Backing Track (GLOBAL)
        function openYoutubeBackingTrack(artist, track) {
            const searchQuery = `${artist} ${track} backing track`;
            const encodedQuery = encodeURIComponent(searchQuery);
            const youtubeUrl = `https://www.youtube.com/results?search_query=${encodedQuery}`;
            window.open(youtubeUrl, '_blank');
            showMessage(`Searching for "${track}" backing track on YouTube...`);
        }

        // Open Ultimate Guitar Tabs
        function openUltimateGuitar(track, artist) {
            const searchQuery = `${artist} ${track}`;
            const encodedQuery = encodeURIComponent(searchQuery);
            const ultimateGuitarUrl = `https://www.ultimate-guitar.com/search.php?search_type=title&value=${encodedQuery}`;
            window.open(ultimateGuitarUrl, '_blank');
            showMessage(`Searching for "${track}" tabs on Ultimate Guitar...`);
        }

        // Add event listeners
        searchButtonEl.addEventListener('click', performSearch);

        // Event listener for search type change
        document.querySelectorAll('input[name="search-type"]').forEach(radio => {
            radio.addEventListener('change', handleSearchTypeChange);
        });

        // Event listener for real-time search (artists only)
        artistSearchEl.addEventListener('input', (e) => {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;
            if (searchType === 'artist') {
                const query = e.target.value.trim();

                // Cancel previous timeout
                if (suggestionTimeout) {
                    clearTimeout(suggestionTimeout);
                }

                // Set new timeout to avoid too many requests
                suggestionTimeout = setTimeout(() => {
                    fetchSuggestions(query);
                }, 300); // Wait 300ms after last keystroke
            }
        });

        // Event listener for real-time track search
        trackSearchEl.addEventListener('input', (e) => {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;
            if (searchType === 'track') {
                const query = e.target.value.trim();

                // Cancel previous timeout
                if (trackSuggestionTimeout) {
                    clearTimeout(trackSuggestionTimeout);
                }

                // Set new timeout to avoid too many requests
                trackSuggestionTimeout = setTimeout(() => {
                    fetchTrackSuggestions(query);
                }, 300); // Wait 300ms after last keystroke
            }
        });

        // Event listener for real-time best-of search
        bestOfSearchEl.addEventListener('input', (e) => {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;
            if (searchType === 'best-of') {
                const query = e.target.value.trim();

                // Cancel previous timeout
                if (bestOfSuggestionTimeout) {
                    clearTimeout(bestOfSuggestionTimeout);
                }

                // Set new timeout to avoid too many requests
                bestOfSuggestionTimeout = setTimeout(() => {
                    fetchBestOfSuggestions(query);
                }, 300); // Wait 300ms after last keystroke
            }
        });

        // Handle keyboard navigation
        artistSearchEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
            } else {
                handleKeyNavigation(e);
            }
        });

        // Handle keyboard navigation for track search
        trackSearchEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
            } else {
                handleTrackKeyNavigation(e);
            }
        });

        // Handle keyboard navigation for best-of search
        bestOfSearchEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
            } else {
                handleBestOfKeyNavigation(e);
            }
        });

        // Handle Enter for genre
        genreSelectEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#artist-search') && !e.target.closest('#search-suggestions')) {
                hideSuggestions();
            }
            if (!e.target.closest('#track-search') && !e.target.closest('#track-suggestions')) {
                hideTrackSuggestions();
            }
            if (!e.target.closest('#best-of-search') && !e.target.closest('#best-of-suggestions')) {
                hideBestOfSuggestions();
            }
            if (!e.target.closest('#history-button') && !e.target.closest('#search-history-dropdown')) {
                hideSearchHistory();
            }
        });

        // Handle focus to show suggestions again if needed
        artistSearchEl.addEventListener('focus', () => {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;
            if (searchType === 'artist') {
                const query = artistSearchEl.value.trim();
                if (query.length >= 2 && currentSuggestions.length > 0) {
                    showSuggestions();
                }
            }
        });

        // Handle focus for track search
        trackSearchEl.addEventListener('focus', () => {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;
            if (searchType === 'track') {
                const query = trackSearchEl.value.trim();
                if (query.length >= 2 && currentTrackSuggestions.length > 0) {
                    showTrackSuggestions();
                }
            }
        });

        // Handle focus for best-of search
        bestOfSearchEl.addEventListener('focus', () => {
            const searchType = document.querySelector('input[name="search-type"]:checked').value;
            if (searchType === 'best-of') {
                const query = bestOfSearchEl.value.trim();
                if (query.length >= 2 && currentBestOfSuggestions.length > 0) {
                    showBestOfSuggestions();
                }
            }
        });

        // Event listeners for search history
        document.getElementById('history-button').addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('search-history-dropdown');
            if (dropdown.classList.contains('hidden')) {
                showSearchHistory();
            } else {
                hideSearchHistory();
            }
        });

        document.getElementById('clear-history-button').addEventListener('click', (e) => {
            e.stopPropagation();
            clearSearchHistory();
        });

        // Event listeners for favorites
        favoritesButtonEl.addEventListener('click', showFavorites);
        closeFavoritesEl.addEventListener('click', hideFavorites);

        // Event listeners for favorites menu
        favoritesMenuToggleEl.addEventListener('click', toggleFavoritesMenu);
        exportFavoritesEl.addEventListener('click', exportFavorites);
        importFavoritesEl.addEventListener('click', importFavorites);
        importFileInputEl.addEventListener('change', handleFileImport);
        githubRepoEl.addEventListener('click', openGitHubRepo);

        // Close favorites by clicking outside the window
        favoritesOverlayEl.addEventListener('click', (e) => {
            if (e.target === favoritesOverlayEl) {
                hideFavorites();
            }
        });

        // Close favorites with ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !favoritesOverlayEl.classList.contains('hidden')) {
                hideFavorites();
            }
        });

        // Close favorites menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#favorites-menu') && !e.target.closest('#favorites-menu-toggle')) {
                hideFavoritesMenu();
            }
        });

        // Event listeners for theme selector
        document.querySelectorAll('.theme-option').forEach(option => {
            option.addEventListener('click', () => {
                const theme = option.getAttribute('data-theme');
                changeTheme(theme);
            });
        });

        // Event listener for random song button
        document.getElementById('random-song-btn').addEventListener('click', getRandomSong);

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            loadTheme(); // Load saved theme
            initializeGenres();
            initializeMoods();
            handleSearchTypeChange(); // Set initial state
            loadFavorites(); // Load saved favorites
            loadSearchHistory(); // Load search history
        });
    </script>
</body>

</html>